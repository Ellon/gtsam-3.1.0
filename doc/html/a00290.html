<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>gtsam: gtsam Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">gtsam
   &#160;<span id="projectnumber">3.1.0</span>
   </div>
   <div id="projectbrief">gtsam</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00290.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">gtsam Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Global functions in a separate testing namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:a00546"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00546.html">noiseModel</a></td></tr>
<tr class="memdesc:a00546"><td class="mdescLeft">&#160;</td><td class="mdescRight">All noise models live in the <a class="el" href="a00546.html" title="All noise models live in the noiseModel namespace.">noiseModel</a> namespace. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00552"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00552.html">treeTraversal</a></td></tr>
<tr class="memdesc:a00552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal functions used for traversing trees. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00035.html">ConcurrentMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00048.html">DerivedValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00065.html">DSFBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00066.html">DSFVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00087.html">FastList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00088.html">FastMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html">FastSetTestableHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00089.html">FastSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00091.html">FastSetTestableHelper&lt; VALUE, typename boost::enable_if&lt; has_print&lt; VALUE &gt; &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00092.html">FastVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00114.html">GroupConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This concept check enforces a Group structure on a variable type, in which we require the existence of basic algebraic operations.  <a href="a00114.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00149.html">LieConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept check class for Lie group type.  <a href="a00149.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00150.html">LieMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00152.html" title="LieVector is a wrapper around vector to allow it to be a Lie type.">LieVector</a> is a wrapper around vector to allow it to be a Lie type.  <a href="a00150.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00151.html">LieScalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00151.html" title="LieScalar is a wrapper around double to allow it to be a Lie type.">LieScalar</a> is a wrapper around double to allow it to be a Lie type.  <a href="a00151.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00152.html">LieVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00152.html" title="LieVector is a wrapper around vector to allow it to be a Lie type.">LieVector</a> is a wrapper around vector to allow it to be a Lie type.  <a href="a00152.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00155.html">ManifoldConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept check class for Manifold types Requires a mapping between a linear tangent space and the underlying manifold, of which Lie is a specialization.  <a href="a00155.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00094.html">G_x1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that computes the derivative of f w.r.t.  <a href="a00094.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00228.html">SymmetricBlockMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00031.html">CholeskyFailed</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00229.html">SymmetricBlockMatrixBlockExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix expression that references a single block of a <a class="el" href="a00228.html">SymmetricBlockMatrix</a>.  <a href="a00229.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00232.html">TestableConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00073.html">equals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template to create a binary predicate.  <a href="a00073.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00074.html">equals_star</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary predicate on shared pointers.  <a href="a00074.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00038.html">const_selector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that uses templates to select between two types based on whether TEST_TYPE is const or not.  <a href="a00038.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00039.html">const_selector&lt; BASIC_TYPE, BASIC_TYPE, AS_NON_CONST, AS_CONST &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the non-const version.  <a href="a00039.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00040.html">const_selector&lt; const BASIC_TYPE, BASIC_TYPE, AS_NON_CONST, AS_CONST &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the const version.  <a href="a00040.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00248.html">ValueWithDefault</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct that encapsulates a value with a default, this is just used as a member object so you don't have to specify defaults in the class constructor.  <a href="a00248.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00154.html">ListOfOneContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class that behaves as a container with one element, and works with boost::range.  <a href="a00154.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00233.html">ThreadsafeException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base exception type that uses tbb_exception if GTSAM is compiled with TBB.  <a href="a00233.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00208.html">RuntimeErrorThreadsafe</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threadsafe runtime error exception.  <a href="a00208.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00183.html">OutOfRangeThreadsafe</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threadsafe runtime error exception.  <a href="a00183.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00120.html">InvalidArgumentThreadsafe</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Threadsafe invalid argument exception.  <a href="a00120.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00231.html">TbbOpenMPMixedScope</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object whose scope defines a block where TBB and OpenMP parallelism are mixed.  <a href="a00231.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00242.html">Value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the interface class for any value that may be used as a variable assignment in a factor graph, and which you must derive to create new variable types to use with gtsam.  <a href="a00242.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00253.html">VerticalBlockMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00021.html">Cal3_S2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html">Cal3_S2Stereo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html">Cal3Bundler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00024.html">Cal3DS2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00025.html">Cal3Unified</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00029.html">CheiralityException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00026.html">CalibratedCamera</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00190.html">PoseConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pose Concept A must contain a translation and a rotation, with each structure accessable directly and a type provided for each.  <a href="a00190.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00197.html">RangeMeasurementConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range measurement concept Given a pair of Lie variables, there must exist a function to calculate range with derivatives.  <a href="a00197.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00076.html">EssentialMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An essential matrix is like a <a class="el" href="a00189.html">Pose3</a>, except with translation up to scale It is named after the 3*3 matrix aEb = [aTb]x aRb from computer vision, but here we choose instead to parameterize it as a (<a class="el" href="a00205.html">Rot3</a>,<a class="el" href="a00241.html" title="Represents a 3D point on a unit sphere.">Unit3</a>) pair.  <a href="a00076.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00185.html">PinholeCamera</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00186.html">Point2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00187.html">Point3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00188.html">Pose2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00189.html">Pose3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00204.html">Rot2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00205.html">Rot3</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00222.html">StereoCheiralityException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00221.html">StereoCamera</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00223.html">StereoPoint2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00238.html">TriangulationUnderconstrainedException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown by triangulateDLT when SVD returns rank &lt; 3.  <a href="a00238.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00236.html">TriangulationCheiralityException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown by triangulateDLT when landmark is behind one or more of the cameras.  <a href="a00236.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00237.html">TriangulationFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00241.html">Unit3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 3D point on a unit sphere.  <a href="a00241.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00009.html">BayesNet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="a00009.html" title="A BayesNet is a tree of conditionals, stored in elimination order.">BayesNet</a> is a tree of conditionals, stored in elimination order.  <a href="a00009.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00083.html">FactorGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factor graph is a bipartite graph with factor nodes connected to variable nodes.  <a href="a00083.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00033.html">ClusterTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cluster-tree is associated with a factor graph and is defined as in Koller-Friedman: each node k represents a subset \( C_k \sub X \), and the tree is family preserving, in that each factor \( f_i \) is associated with a single cluster and \( scope(f_i) \sub C_k \).  <a href="a00033.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00013.html">BayesTreeCliqueStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">clique statistics  <a href="a00013.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00012.html">BayesTreeCliqueData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">store all the sizes  <a href="a00012.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html">BayesTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00014.html">BayesTreeOrphanWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00069.html">EliminationTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class for eliminateable factor graphs, specifies the types that result from elimination, etc.  <a href="a00069.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html">BayesTreeCliqueBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for <a class="el" href="a00010.html">BayesTree</a> cliques.  <a href="a00011.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html">Conditional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: Update comments.  <a href="a00036.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00068.html">EliminateableFactorGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00068.html" title="EliminateableFactorGraph is a base class for factor graphs that contains elimination algorithms...">EliminateableFactorGraph</a> is a base class for factor graphs that contains elimination algorithms.  <a href="a00068.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00072.html">EliminationTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An elimination tree is a data structure used intermediately during elimination.  <a href="a00072.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00082.html">Factor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the base class for all factor types.  <a href="a00082.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00045.html">CRefCallPushBack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper.  <a href="a00045.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00198.html">RefCallPushBack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper.  <a href="a00198.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00044.html">CRefCallAddCopy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper.  <a href="a00044.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00182.html">ordering_key_visitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00034.html">compose_key_visitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00211.html">SDGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00211.html" title="SDGraph is undirected graph with variable keys and double edge weights.">SDGraph</a> is undirected graph with variable keys and double edge weights.  <a href="a00211.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00214.html">SGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00194.html">PredecessorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map from variable key to parent key.  <a href="a00194.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00118.html">InconsistentEliminationRequested</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An inference algorithm was called with inconsistent arguments.  <a href="a00118.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00124.html">ISAM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Bayes tree with an update methods that implements the iSAM algorithm.  <a href="a00124.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00141.html">JunctionTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00144.html">LabeledSymbol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Customized version of <a class="el" href="a00227.html" title="Character and index key used in VectorValues, GaussianFactorGraph, GaussianFactor, etc.">gtsam::Symbol</a> for multi-robot use.  <a href="a00144.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00181.html">Ordering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00227.html">Symbol</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Character and index key used in <a class="el" href="a00252.html" title="This class represents a collection of vector-valued variables associated each with a unique integer i...">VectorValues</a>, <a class="el" href="a00103.html" title="A Linear Factor Graph is a factor graph where all factors are Gaussian, i.e.">GaussianFactorGraph</a>, <a class="el" href="a00102.html" title="An abstract virtual base class for JacobianFactor and HessianFactor.">GaussianFactor</a>, etc.  <a href="a00227.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00249.html">VariableIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="a00249.html" title="The VariableIndex class computes and stores the block column structure of a factor graph...">VariableIndex</a> class computes and stores the block column structure of a factor graph.  <a href="a00249.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00250.html">VariableSlots</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A combined factor is assembled as one block of rows for each component factor.  <a href="a00250.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00003.html">AlgebraicDecisionTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Algebraic Decision Trees fix the range to double Just has some nice constructors and some syntactic sugar TODO: consider eliminating this class altogether?  <a href="a00003.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00005.html">Assignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An assignment from labels to value index (size_t).  <a href="a00005.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00046.html">DecisionTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decision Tree L = label for variables Y = function range (any algebra), e.g., bool, int, double.  <a href="a00046.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00047.html">DecisionTreeFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A discrete probabilistic factor.  <a href="a00047.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00051.html">DiscreteBayesNet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Bayes net made from linear-Discrete densities.  <a href="a00051.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00053.html">DiscreteBayesTreeClique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A clique in a <a class="el" href="a00052.html" title="A Bayes tree representing a Discrete density.">DiscreteBayesTree</a>.  <a href="a00053.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00052.html">DiscreteBayesTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Bayes tree representing a Discrete density.  <a href="a00052.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00054.html">DiscreteConditional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discrete <a class="el" href="a00036.html" title="TODO: Update comments.">Conditional</a> Density Derives from <a class="el" href="a00047.html" title="A discrete probabilistic factor.">DecisionTreeFactor</a>.  <a href="a00054.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00055.html">DiscreteEliminationTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00056.html">DiscreteFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for discrete probabilistic factors The most general one is the derived <a class="el" href="a00047.html" title="A discrete probabilistic factor.">DecisionTreeFactor</a>.  <a href="a00056.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00070.html">EliminationTraits&lt; DiscreteFactorGraph &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00057.html">DiscreteFactorGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Discrete <a class="el" href="a00082.html" title="This is the base class for all factor types.">Factor</a> Graph is a factor graph where all factors are Discrete, i.e.  <a href="a00057.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00058.html">DiscreteJunctionTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00059.html">DiscreteKeys</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00059.html" title="DiscreteKeys is a set of keys that can be assembled using the &amp; operator.">DiscreteKeys</a> is a set of keys that can be assembled using the &amp; operator.  <a href="a00059.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00060.html">DiscreteMarginals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for computing marginals of variables in a <a class="el" href="a00057.html" title="A Discrete Factor Graph is a factor graph where all factors are Discrete, i.e.">DiscreteFactorGraph</a>.  <a href="a00060.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00193.html">Potentials</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for both <a class="el" href="a00056.html" title="Base class for discrete probabilistic factors The most general one is the derived DecisionTreeFactor...">DiscreteFactor</a> and <a class="el" href="a00054.html" title="Discrete Conditional Density Derives from DecisionTreeFactor.">DiscreteConditional</a>.  <a href="a00193.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00215.html">Signature</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00215.html" title="Signature for a discrete conditional density, used to construct conditionals.">Signature</a> for a discrete conditional density, used to construct conditionals.  <a href="a00215.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00037.html">ConjugateGradientParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">parameters for the conjugate gradient method  <a href="a00037.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00075.html">Errors</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of errors  <a href="a00075.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00096.html">GaussianBayesNet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Bayes net made from linear-Gaussian densities.  <a href="a00096.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00098.html">GaussianBayesTreeClique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A clique in a <a class="el" href="a00097.html" title="A Bayes tree representing a Gaussian density.">GaussianBayesTree</a>.  <a href="a00098.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00097.html">GaussianBayesTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Bayes tree representing a Gaussian density.  <a href="a00097.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00099.html">GaussianConditional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A conditional Gaussian functions as the node in a Bayes network It has a set of parents y,z, etc.  <a href="a00099.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00100.html">GaussianDensity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Gaussian density.  <a href="a00100.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00101.html">GaussianEliminationTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00102.html">GaussianFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstract virtual base class for <a class="el" href="a00135.html" title="A Gaussian factor in the squared-error form.">JacobianFactor</a> and <a class="el" href="a00115.html" title="A Gaussian factor using the canonical parameters (information form)">HessianFactor</a>.  <a href="a00102.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00071.html">EliminationTraits&lt; GaussianFactorGraph &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00103.html">GaussianFactorGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Linear <a class="el" href="a00082.html" title="This is the base class for all factor types.">Factor</a> Graph is a factor graph where all factors are Gaussian, i.e.  <a href="a00103.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00104.html">GaussianISAM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00105.html">GaussianJunctionTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00216.html">SlotEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">One <a class="el" href="a00216.html" title="One SlotEntry stores the slot index for a variable, as well its dimension.">SlotEntry</a> stores the slot index for a variable, as well its dimension.  <a href="a00216.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00210.html">Scatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00210.html" title="Scatter is an intermediate data structure used when building a HessianFactor incrementally, to get the keys in the right order.">Scatter</a> is an intermediate data structure used when building a <a class="el" href="a00115.html" title="A Gaussian factor using the canonical parameters (information form)">HessianFactor</a> incrementally, to get the keys in the right order.  <a href="a00210.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00115.html">HessianFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Gaussian factor using the canonical parameters (information form)  <a href="a00115.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00028.html">CGState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00230.html">System</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class encapsulating the combined system |Ax-b_|^2 Needed to run Conjugate Gradients on matrices.  <a href="a00230.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00133.html">IterativeOptimizationParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">parameters for iterative linear solvers  <a href="a00133.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html">IterativeSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00135.html">JacobianFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Gaussian factor in the squared-error form.  <a href="a00135.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00142.html">KalmanFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kalman Filter class.  <a href="a00142.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00119.html">IndeterminantLinearSystemException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when a linear system is ill-posed.  <a href="a00119.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00123.html">InvalidNoiseModel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception indicating that the noise model dimension passed into a <a class="el" href="a00135.html" title="A Gaussian factor in the squared-error form.">JacobianFactor</a> has a different dimensionality than the factor.  <a href="a00123.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00122.html">InvalidMatrixBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An exception indicating that a matrix block passed into a <a class="el" href="a00135.html" title="A Gaussian factor in the squared-error form.">JacobianFactor</a> has a different dimensionality than the factor.  <a href="a00122.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00121.html">InvalidDenseElimination</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00209.html">Sampler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sampling structure that keeps internal random number generators for diagonal distributions specified by NoiseModel.  <a href="a00209.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00224.html">SubgraphPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subgraph conditioner class, as explained in the RSS 2010 submission.  <a href="a00224.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00226.html">SubgraphSolverParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00225.html">SubgraphSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the SPCG solver presented in Dellaert et al in IROS'10.  <a href="a00225.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00252.html">VectorValues</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a collection of vector-valued variables associated each with a unique integer index.  <a href="a00252.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00063.html">DoglegParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for Levenberg-Marquardt optimization.  <a href="a00063.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00064.html">DoglegState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State for <a class="el" href="a00061.html" title="This class performs Dogleg nonlinear optimization.">DoglegOptimizer</a>.  <a href="a00064.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00061.html">DoglegOptimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class performs Dogleg nonlinear optimization.  <a href="a00061.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00062.html">DoglegOptimizerImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains the implementation of the Dogleg algorithm.  <a href="a00062.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00081.html">ExtendedKalmanFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a generic Extended Kalman Filter class implemented using nonlinear factors.  <a href="a00081.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00107.html">GaussNewtonParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for Gauss-Newton optimization, inherits from NonlinearOptimizationParams.  <a href="a00107.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00108.html">GaussNewtonState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00106.html">GaussNewtonOptimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class performs Gauss-Newton nonlinear optimization.  <a href="a00106.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00125.html">ISAM2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00128.html">ISAM2GaussNewtonParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00127.html">ISAM2DoglegParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00129.html">ISAM2Params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00130.html">ISAM2Result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00126.html">ISAM2Clique</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized Clique structure for <a class="el" href="a00125.html">ISAM2</a>, incorporating caching and gradient contribution TODO: more documentation.  <a href="a00126.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00147.html">LevenbergMarquardtParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for Levenberg-Marquardt optimization.  <a href="a00147.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00148.html">LevenbergMarquardtState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">State for <a class="el" href="a00146.html" title="This class performs Levenberg-Marquardt nonlinear optimization.">LevenbergMarquardtOptimizer</a>.  <a href="a00148.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00146.html">LevenbergMarquardtOptimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class performs Levenberg-Marquardt nonlinear optimization.  <a href="a00146.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00153.html">LinearContainerFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dummy version of a generic linear factor to be injected into a nonlinear factor graph.  <a href="a00153.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00157.html">Marginals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for computing Gaussian marginals of variables in a <a class="el" href="a00173.html" title="A non-linear factor graph is a graph of non-Gaussian, i.e.">NonlinearFactorGraph</a>.  <a href="a00157.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00140.html">JointMarginal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to store and access a joint marginal, returned from <a class="el" href="a00157.html#a72725b4ec9f8730618ddfbcdd0ba52d8" title="Compute the joint marginal covariance of several variables.">Marginals::jointMarginalCovariance</a> and <a class="el" href="a00157.html#aff9594cec09117bdb69214a3924f9569" title="Compute the joint marginal information of several variables.">Marginals::jointMarginalInformation</a>.  <a href="a00140.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00168.html">NonlinearConjugateGradientState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of the nonlinear cg method using the template below.  <a href="a00168.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00167.html">NonlinearConjugateGradientOptimizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00169.html">NonlinearEquality</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An equality factor that forces either one variable to a constant, or a set of variables to be equal to each other.  <a href="a00169.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00170.html">NonlinearEquality1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple unary equality constraint - fixes a value for a variable.  <a href="a00170.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00171.html">NonlinearEquality2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple binary equality constraint - this constraint forces two factors to be the same.  <a href="a00171.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00156.html">MarginalizeNonleafException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thrown when requesting to marginalize out variables from <a class="el" href="a00125.html">ISAM2</a> that are not leaves.  <a href="a00156.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00172.html">NonlinearFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nonlinear factor base class.  <a href="a00172.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00160.html">NoiseModelFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A nonlinear sum-of-squares factor with a zero-mean noise model implementing the density \( P(z|x) \propto exp -0.5*|z-h(x)|^2_C \) Templated on the parameter type X and the values structure <a class="el" href="a00244.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a> There is no return type specified for h(x).  <a href="a00160.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00161.html">NoiseModelFactor1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient base class for creating your own <a class="el" href="a00160.html" title="A nonlinear sum-of-squares factor with a zero-mean noise model implementing the density  Templated on...">NoiseModelFactor</a> with 1 variable.  <a href="a00161.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00162.html">NoiseModelFactor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient base class for creating your own <a class="el" href="a00160.html" title="A nonlinear sum-of-squares factor with a zero-mean noise model implementing the density  Templated on...">NoiseModelFactor</a> with 2 variables.  <a href="a00162.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00163.html">NoiseModelFactor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient base class for creating your own <a class="el" href="a00160.html" title="A nonlinear sum-of-squares factor with a zero-mean noise model implementing the density  Templated on...">NoiseModelFactor</a> with 3 variables.  <a href="a00163.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00164.html">NoiseModelFactor4</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient base class for creating your own <a class="el" href="a00160.html" title="A nonlinear sum-of-squares factor with a zero-mean noise model implementing the density  Templated on...">NoiseModelFactor</a> with 4 variables.  <a href="a00164.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00165.html">NoiseModelFactor5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient base class for creating your own <a class="el" href="a00160.html" title="A nonlinear sum-of-squares factor with a zero-mean noise model implementing the density  Templated on...">NoiseModelFactor</a> with 5 variables.  <a href="a00165.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00166.html">NoiseModelFactor6</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenient base class for creating your own <a class="el" href="a00160.html" title="A nonlinear sum-of-squares factor with a zero-mean noise model implementing the density  Templated on...">NoiseModelFactor</a> with 6 variables.  <a href="a00166.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00113.html">GraphvizFormatting</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formatting options when saving in GraphViz format using <a class="el" href="a00173.html#af4fe6c4a779bbc8b985ffdb6b55c3227" title="Write the graph in GraphViz format for visualization.">NonlinearFactorGraph::saveGraph</a>.  <a href="a00113.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00173.html">NonlinearFactorGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-linear factor graph is a graph of non-Gaussian, i.e.  <a href="a00173.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00174.html">NonlinearISAM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class to manage <a class="el" href="a00124.html" title="A Bayes tree with an update methods that implements the iSAM algorithm.">ISAM</a> in a nonlinear context.  <a href="a00174.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00177.html">NonlinearOptimizerState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for a nonlinear optimization state, including the current estimate of the variable values, error, and number of iterations.  <a href="a00177.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00175.html">NonlinearOptimizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the abstract interface for classes that can optimize for the maximum-likelihood estimate of a <a class="el" href="a00173.html" title="A non-linear factor graph is a graph of non-Gaussian, i.e.">NonlinearFactorGraph</a>.  <a href="a00175.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00176.html">NonlinearOptimizerParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The common parameters for Nonlinear optimizers.  <a href="a00176.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00243.html">ValueCloneAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00002.html">_ValuesKeyValuePair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00001.html">_ValuesConstKeyValuePair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00244.html">Values</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-templated config holding any types of Manifold-group elements.  <a href="a00244.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00246.html">ValuesKeyAlreadyExists</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00247.html">ValuesKeyDoesNotExist</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00245.html">ValuesIncorrectType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00067.html">DynamicValuesMismatched</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00255.html">WhiteNoiseFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary factor to estimate parameters of zero-mean Gaussian white noise.  <a href="a00255.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00004.html">AntiFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00015.html">BearingFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00016.html">BearingRangeFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00018.html">BetweenFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00017.html">BetweenConstraint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary between constraint - forces between to a given value This constraint requires the underlying type to a Lie type.  <a href="a00017.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00019.html">BoundingConstraint1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00020.html">BoundingConstraint2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary scalar inequality constraint, with a similar <a class="el" href="a00020.html#ad1415ee808cefd215e6410c6dd9f4f51" title="function producing a scalar value to compare to the threshold Must have optional argument for derivat...">value()</a> function to implement for specific systems.  <a href="a00020.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00213.html">SfM_Track</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the structure for the 3D points.  <a href="a00213.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00212.html">SfM_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the structure for SfM data.  <a href="a00212.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00077.html">EssentialMatrixConstraint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00078.html">EssentialMatrixFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00082.html" title="This is the base class for all factor types.">Factor</a> that evaluates epipolar error p'Ep for given essential matrix.  <a href="a00078.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00079.html">EssentialMatrixFactor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary factor that optimizes for E and inverse depth d: assumes measurement in image 2 is perfect, and returns re-projection error in image 1.  <a href="a00079.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00080.html">EssentialMatrixFactor3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary factor that optimizes for E and inverse depth d: assumes measurement in image 2 is perfect, and returns re-projection error in image 1 This version takes an extrinsic rotation to allow for omni-directional rigs.  <a href="a00080.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00109.html">GeneralSFMFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00110.html">GeneralSFMFactor2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-linear factor for a constraint derived from a 2D measurement.  <a href="a00110.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00117.html">ImplicitSchurFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00117.html" title="ImplicitSchurFactor.">ImplicitSchurFactor</a>.  <a href="a00117.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00136.html">JacobianFactorQ</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00135.html" title="A Gaussian factor in the squared-error form.">JacobianFactor</a> for Schur complement that uses Q noise model.  <a href="a00136.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00137.html">JacobianFactorQR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00135.html" title="A Gaussian factor in the squared-error form.">JacobianFactor</a> for Schur complement that uses Q noise model.  <a href="a00137.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00138.html">JacobianFactorSVD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00135.html" title="A Gaussian factor in the squared-error form.">JacobianFactor</a> for Schur complement that uses Q noise model.  <a href="a00138.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00139.html">JacobianSchurFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00135.html" title="A Gaussian factor in the squared-error form.">JacobianFactor</a> for Schur complement that uses Q noise model.  <a href="a00139.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00191.html">PoseRotationPrior</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00192.html">PoseTranslationPrior</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A prior on the translation part of a pose.  <a href="a00192.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00195.html">PriorFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00111.html">GenericProjectionFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html">RangeFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00199.html">ReferenceFrameFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constraint between two landmarks in separate maps Templated on: Point : Type of landmark Transform : Transform variable class.  <a href="a00199.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00200.html">RegularHessianFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00207.html">RotateFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00082.html" title="This is the base class for all factor types.">Factor</a> on unknown rotation iRC that relates two incremental rotations c1Rc2 = iRc' * i1Ri2 * iRc Which we can write (see doc/math.lyx) e^[z] = iRc' * e^[p] * iRc = e^([iRc'*p]) with z and p measured and predicted angular velocities, and hence p = iRc * z.  <a href="a00207.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00206.html">RotateDirectionsFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00082.html" title="This is the base class for all factor types.">Factor</a> on unknown rotation R that relates two directions p_i = iRc * z_c Directions provide less constraints than a full rotation.  <a href="a00206.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00217.html">SmartFactorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class with no internal point, completely functional.  <a href="a00217.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00219.html">SmartProjectionFactorState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00218.html">SmartProjectionFactor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00218.html" title="SmartProjectionFactor: triangulates point TODO: why LANDMARK parameter?">SmartProjectionFactor</a>: triangulates point TODO: why LANDMARK parameter?  <a href="a00218.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00220.html">SmartProjectionPoseFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00112.html">GenericStereoFactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a03a792d93b6d3283b4c2f3fb5954190f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03a792d93b6d3283b4c2f3fb5954190f"></a>
typedef Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><b>Matrix</b></td></tr>
<tr class="separator:a03a792d93b6d3283b4c2f3fb5954190f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14bcd25aa57e5e0477389b9a08b9098"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae14bcd25aa57e5e0477389b9a08b9098"></a>
typedef Eigen::Matrix&lt; double, <br class="typebreak"/>
Eigen::Dynamic, Eigen::Dynamic, <br class="typebreak"/>
Eigen::RowMajor &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixRowMajor</b></td></tr>
<tr class="separator:ae14bcd25aa57e5e0477389b9a08b9098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384af2a352b80410963045e4aefd2022"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a384af2a352b80410963045e4aefd2022"></a>
typedef Eigen::Matrix3d&#160;</td><td class="memItemRight" valign="bottom"><b>Matrix3</b></td></tr>
<tr class="separator:a384af2a352b80410963045e4aefd2022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476d1a6dc0b0dd54614c98c0e00decfa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a476d1a6dc0b0dd54614c98c0e00decfa"></a>
typedef Eigen::Matrix4d&#160;</td><td class="memItemRight" valign="bottom"><b>Matrix4</b></td></tr>
<tr class="separator:a476d1a6dc0b0dd54614c98c0e00decfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b70291bcbb7bca8c0e4a2e8c45954c3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b70291bcbb7bca8c0e4a2e8c45954c3"></a>
typedef Eigen::Matrix&lt; double, 6, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Matrix6</b></td></tr>
<tr class="separator:a3b70291bcbb7bca8c0e4a2e8c45954c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3218833aef585dcaf060bdef7c8ee861"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3218833aef585dcaf060bdef7c8ee861"></a>
typedef Eigen::Block&lt; Matrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SubMatrix</b></td></tr>
<tr class="separator:a3218833aef585dcaf060bdef7c8ee861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7197dd6ad1eee8ece9aa15edbabc3b68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7197dd6ad1eee8ece9aa15edbabc3b68"></a>
typedef Eigen::Block&lt; const <br class="typebreak"/>
Matrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstSubMatrix</b></td></tr>
<tr class="separator:a7197dd6ad1eee8ece9aa15edbabc3b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa365a1bd3614e767adbd35f44ba4fec3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa365a1bd3614e767adbd35f44ba4fec3"></a>
typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a></td></tr>
<tr class="memdesc:aa365a1bd3614e767adbd35f44ba4fec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer nonlinear key type. <br/></td></tr>
<tr class="separator:aa365a1bd3614e767adbd35f44ba4fec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29dee574fe60f586d71b2c0d957dc8bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29dee574fe60f586d71b2c0d957dc8bb"></a>
typedef boost::function<br class="typebreak"/>
&lt; std::string(<a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a29dee574fe60f586d71b2c0d957dc8bb">KeyFormatter</a></td></tr>
<tr class="memdesc:a29dee574fe60f586d71b2c0d957dc8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a function to format a key, i.e. to convert it to a string. <br/></td></tr>
<tr class="separator:a29dee574fe60f586d71b2c0d957dc8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21006f326f57cdf7d3f35fec40f43e40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21006f326f57cdf7d3f35fec40f43e40"></a>
typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a21006f326f57cdf7d3f35fec40f43e40">DenseIndex</a></td></tr>
<tr class="memdesc:a21006f326f57cdf7d3f35fec40f43e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">The index type for Eigen objects. <br/></td></tr>
<tr class="separator:a21006f326f57cdf7d3f35fec40f43e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6a39f5eb77f4d28961cef67ebf98f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad6a39f5eb77f4d28961cef67ebf98f3"></a>
typedef Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><b>Vector</b></td></tr>
<tr class="separator:aad6a39f5eb77f4d28961cef67ebf98f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f77c4fccbc506166116e363c1fa06e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54f77c4fccbc506166116e363c1fa06e"></a>
typedef Eigen::Vector2d&#160;</td><td class="memItemRight" valign="bottom"><b>Vector2</b></td></tr>
<tr class="separator:a54f77c4fccbc506166116e363c1fa06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87074ffb029b86bb8c54edd2a29cb1ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87074ffb029b86bb8c54edd2a29cb1ae"></a>
typedef Eigen::Vector3d&#160;</td><td class="memItemRight" valign="bottom"><b>Vector3</b></td></tr>
<tr class="separator:a87074ffb029b86bb8c54edd2a29cb1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504170338a608d956ffa625dc6375b37"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a504170338a608d956ffa625dc6375b37"></a>
typedef Eigen::Matrix&lt; double, 6, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Vector6</b></td></tr>
<tr class="separator:a504170338a608d956ffa625dc6375b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d1471ff74798e876eac3c5dddc3d53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8d1471ff74798e876eac3c5dddc3d53"></a>
typedef Eigen::VectorBlock<br class="typebreak"/>
&lt; Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SubVector</b></td></tr>
<tr class="separator:ae8d1471ff74798e876eac3c5dddc3d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab75d3757735f345508c14966678e983"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab75d3757735f345508c14966678e983"></a>
typedef Eigen::VectorBlock<br class="typebreak"/>
&lt; const Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstSubVector</b></td></tr>
<tr class="separator:aab75d3757735f345508c14966678e983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15dec8cc8bf0a43bc649709b84cf771"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af15dec8cc8bf0a43bc649709b84cf771"></a>
typedef std::pair&lt; <a class="el" href="a00186.html">Point2</a>, <a class="el" href="a00186.html">Point2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#af15dec8cc8bf0a43bc649709b84cf771">Point2Pair</a></td></tr>
<tr class="memdesc:af15dec8cc8bf0a43bc649709b84cf771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate pose between a vector of 2D point correspondences (p,q) where q = Pose2::transform_from(p) = t + R*p. <br/></td></tr>
<tr class="separator:af15dec8cc8bf0a43bc649709b84cf771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac387ee14e9f8e8dc341a6f58330241eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac387ee14e9f8e8dc341a6f58330241eb"></a>
typedef std::pair&lt; <a class="el" href="a00187.html">Point3</a>, <a class="el" href="a00187.html">Point3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ac387ee14e9f8e8dc341a6f58330241eb">Point3Pair</a></td></tr>
<tr class="memdesc:ac387ee14e9f8e8dc341a6f58330241eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate pose between a vector of 3D point correspondences (p,q) where q = Pose3::transform_from(p) = t + R*p. <br/></td></tr>
<tr class="separator:ac387ee14e9f8e8dc341a6f58330241eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e2c1120d40da6062c03ab31e869065"><td class="memItemLeft" align="right" valign="top">typedef Eigen::Quaternion<br class="typebreak"/>
&lt; double, Eigen::DontAlign &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a59e2c1120d40da6062c03ab31e869065">Quaternion</a></td></tr>
<tr class="memdesc:a59e2c1120d40da6062c03ab31e869065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef to an Eigen Quaternion&lt;double&gt;, we disable alignment because geometry objects are stored in boost pool allocators, in <a class="el" href="a00244.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a> containers, and and these pool allocators do not support alignment.  <a href="#a59e2c1120d40da6062c03ab31e869065">More...</a><br/></td></tr>
<tr class="separator:a59e2c1120d40da6062c03ab31e869065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb03eb3dceb63b0933c94c15b83cb39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bb03eb3dceb63b0933c94c15b83cb39"></a>
typedef <a class="el" href="a00185.html">PinholeCamera</a>&lt; <a class="el" href="a00021.html">Cal3_S2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a7bb03eb3dceb63b0933c94c15b83cb39">SimpleCamera</a></td></tr>
<tr class="memdesc:a7bb03eb3dceb63b0933c94c15b83cb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple camera class with a <a class="el" href="a00021.html">Cal3_S2</a> calibration. <br/></td></tr>
<tr class="separator:a7bb03eb3dceb63b0933c94c15b83cb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fcb28bfc2908ca506aa5503f24b4c8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fcb28bfc2908ca506aa5503f24b4c8f"></a>
typedef <a class="el" href="a00087.html">FastList</a>&lt; <a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a6fcb28bfc2908ca506aa5503f24b4c8f">KeyList</a></td></tr>
<tr class="memdesc:a6fcb28bfc2908ca506aa5503f24b4c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Useful typedefs for operations with <a class="el" href="a00244.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a> - allow for matlab interfaces. <br/></td></tr>
<tr class="separator:a6fcb28bfc2908ca506aa5503f24b4c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18932dfd5dba41c0574e6db16cdb5932"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18932dfd5dba41c0574e6db16cdb5932"></a>
typedef <a class="el" href="a00092.html">FastVector</a>&lt; <a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeyVector</b></td></tr>
<tr class="separator:a18932dfd5dba41c0574e6db16cdb5932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea882e1ed30f89066e79a37dc5aa7b54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea882e1ed30f89066e79a37dc5aa7b54"></a>
typedef <a class="el" href="a00089.html">FastSet</a>&lt; <a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeySet</b></td></tr>
<tr class="separator:aea882e1ed30f89066e79a37dc5aa7b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17abcfba003e501d2737a344e436a248"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17abcfba003e501d2737a344e436a248"></a>
typedef <a class="el" href="a00088.html">FastMap</a>&lt; <a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a>, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>KeyGroupMap</b></td></tr>
<tr class="separator:a17abcfba003e501d2737a344e436a248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd19e5d1e5d06c37246d4c15af38ee67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd19e5d1e5d06c37246d4c15af38ee67"></a>
typedef std::pair&lt; <a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a>, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#acd19e5d1e5d06c37246d4c15af38ee67">DiscreteKey</a></td></tr>
<tr class="memdesc:acd19e5d1e5d06c37246d4c15af38ee67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key type for discrete conditionals Includes name and cardinality. <br/></td></tr>
<tr class="separator:acd19e5d1e5d06c37246d4c15af38ee67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e5a4884342656e0837ef07008ec03f"><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
noiseModel::Base::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a></td></tr>
<tr class="memdesc:ab6e5a4884342656e0837ef07008ec03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note, deliberately not in <a class="el" href="a00546.html" title="All noise models live in the noiseModel namespace.">noiseModel</a> namespace.  <a href="#ab6e5a4884342656e0837ef07008ec03f">More...</a><br/></td></tr>
<tr class="separator:ab6e5a4884342656e0837ef07008ec03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bc6f977e83dce647b2c006ea3dca5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78bc6f977e83dce647b2c006ea3dca5f"></a>
typedef <br class="typebreak"/>
noiseModel::Gaussian::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>SharedGaussian</b></td></tr>
<tr class="separator:a78bc6f977e83dce647b2c006ea3dca5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413190e269d694931cd6c69fafa7985a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a413190e269d694931cd6c69fafa7985a"></a>
typedef <br class="typebreak"/>
noiseModel::Diagonal::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>SharedDiagonal</b></td></tr>
<tr class="separator:a413190e269d694931cd6c69fafa7985a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62861a84dc6597e73a4d01cfbb36974"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac62861a84dc6597e73a4d01cfbb36974"></a>
typedef <br class="typebreak"/>
noiseModel::Constrained::shared_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>SharedConstrained</b></td></tr>
<tr class="separator:ac62861a84dc6597e73a4d01cfbb36974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663b232e794d75dc8eb4239f12cd2506"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a663b232e794d75dc8eb4239f12cd2506"></a>
typedef <a class="el" href="a00088.html">FastMap</a>&lt; char, Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ISAM2ThresholdMap</b></td></tr>
<tr class="separator:a663b232e794d75dc8eb4239f12cd2506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8707b19ab1e617a8f20c6d68b6d310"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b8707b19ab1e617a8f20c6d68b6d310"></a>
typedef <br class="typebreak"/>
ISAM2ThresholdMap::value_type&#160;</td><td class="memItemRight" valign="bottom"><b>ISAM2ThresholdMapValue</b></td></tr>
<tr class="separator:a1b8707b19ab1e617a8f20c6d68b6d310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4579016a744c3d7adf227ea58623df7f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4579016a744c3d7adf227ea58623df7f"></a>
typedef <a class="el" href="a00176.html">NonlinearOptimizerParams</a>&#160;</td><td class="memItemRight" valign="bottom"><b>SuccessiveLinearizationParams</b></td></tr>
<tr class="separator:a4579016a744c3d7adf227ea58623df7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b6d8d9df4bb6e0add77af1ffd41c04"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62b6d8d9df4bb6e0add77af1ffd41c04"></a>
typedef std::pair<br class="typebreak"/>
&lt; NonlinearFactorGraph::shared_ptr, <br class="typebreak"/>
<a class="el" href="a00244.html#a5b2f07b6054d9ea06b28876a057938d1">Values::shared_ptr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a62b6d8d9df4bb6e0add77af1ffd41c04">GraphAndValues</a></td></tr>
<tr class="memdesc:a62b6d8d9df4bb6e0add77af1ffd41c04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return type for load functions. <br/></td></tr>
<tr class="separator:a62b6d8d9df4bb6e0add77af1ffd41c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424cd75273f459332d71dcf59d8e6157"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a424cd75273f459332d71dcf59d8e6157"></a>
typedef std::pair&lt; size_t, <a class="el" href="a00186.html">Point2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a424cd75273f459332d71dcf59d8e6157">SfM_Measurement</a></td></tr>
<tr class="memdesc:a424cd75273f459332d71dcf59d8e6157"><td class="mdescLeft">&#160;</td><td class="mdescRight">A measurement with its camera index. <br/></td></tr>
<tr class="separator:a424cd75273f459332d71dcf59d8e6157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57df85ec453d878a568bc619734af335"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57df85ec453d878a568bc619734af335"></a>
typedef <a class="el" href="a00185.html">PinholeCamera</a><br class="typebreak"/>
&lt; <a class="el" href="a00023.html">Cal3Bundler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a57df85ec453d878a568bc619734af335">SfM_Camera</a></td></tr>
<tr class="memdesc:a57df85ec453d878a568bc619734af335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the structure for the camera poses. <br/></td></tr>
<tr class="separator:a57df85ec453d878a568bc619734af335"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a90552b70a2da9c74595cae4b05c2ce18"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a90552b70a2da9c74595cae4b05c2ce18">NoiseFormat</a> { <a class="el" href="a00290.html#a90552b70a2da9c74595cae4b05c2ce18ad0aaa5c51a45cb7c9151aae60a603209">NoiseFormatG2O</a>, 
<a class="el" href="a00290.html#a90552b70a2da9c74595cae4b05c2ce18a3790bc2c6f11cd7da84730b33173de5a">NoiseFormatTORO</a>, 
<a class="el" href="a00290.html#a90552b70a2da9c74595cae4b05c2ce18a1f8edeb25c58a249789556c686265a4c">NoiseFormatGRAPH</a>, 
<a class="el" href="a00290.html#a90552b70a2da9c74595cae4b05c2ce18a5450a16f3522214ccdfa23c461e7d05a">NoiseFormatCOV</a>
 }</td></tr>
<tr class="memdesc:a90552b70a2da9c74595cae4b05c2ce18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates how noise parameters are stored in file.  <a href="a00290.html#a90552b70a2da9c74595cae4b05c2ce18">More...</a><br/></td></tr>
<tr class="separator:a90552b70a2da9c74595cae4b05c2ce18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be373f34edc0a9d28b1bfab5dd62ba0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a8be373f34edc0a9d28b1bfab5dd62ba0">KernelFunctionType</a> { <b>KernelFunctionTypeNONE</b>, 
<b>KernelFunctionTypeHUBER</b>, 
<b>KernelFunctionTypeTUKEY</b>
 }</td></tr>
<tr class="memdesc:a8be373f34edc0a9d28b1bfab5dd62ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Robust kernel type to wrap around quadratic noise model. <br/></td></tr>
<tr class="separator:a8be373f34edc0a9d28b1bfab5dd62ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2020f3f6087064dde501c99794aac3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>LinearizationMode</b> { <b>HESSIAN</b>, 
<b>JACOBIAN_SVD</b>, 
<b>JACOBIAN_Q</b>
 }</td></tr>
<tr class="separator:adf2020f3f6087064dde501c99794aac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a747683f736c50bca16b3aab0e95b1b76"><td class="memItemLeft" align="right" valign="top">pair&lt; size_t, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a747683f736c50bca16b3aab0e95b1b76">choleskyCareful</a> (Matrix &amp;ATA, int order=-1)</td></tr>
<tr class="memdesc:a747683f736c50bca16b3aab0e95b1b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Careful" Cholesky computes the positive square-root of a positive symmetric semi-definite matrix (i.e.  <a href="#a747683f736c50bca16b3aab0e95b1b76">More...</a><br/></td></tr>
<tr class="separator:a747683f736c50bca16b3aab0e95b1b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb8c69f6e0b90ac2dec4287ee8fcb0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a1eb8c69f6e0b90ac2dec4287ee8fcb0a">choleskyPartial</a> (Matrix &amp;ABC, size_t nFrontal)</td></tr>
<tr class="memdesc:a1eb8c69f6e0b90ac2dec4287ee8fcb0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial Cholesky computes a factor [R S such that [R' 0 [R S = [A B 0 L] S' I] 0 L] B' C].  <a href="#a1eb8c69f6e0b90ac2dec4287ee8fcb0a">More...</a><br/></td></tr>
<tr class="separator:a1eb8c69f6e0b90ac2dec4287ee8fcb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473aea76af7b0cbec8f26e6abf1ed87e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a473aea76af7b0cbec8f26e6abf1ed87e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a473aea76af7b0cbec8f26e6abf1ed87e">between_default</a> (const T &amp;l1, const T &amp;l2)</td></tr>
<tr class="memdesc:a473aea76af7b0cbec8f26e6abf1ed87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">These core global functions can be specialized by new Lie types for better performance.  <a href="#a473aea76af7b0cbec8f26e6abf1ed87e">More...</a><br/></td></tr>
<tr class="separator:a473aea76af7b0cbec8f26e6abf1ed87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c80ae2fd169fcdd8708c37784a880a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a75c80ae2fd169fcdd8708c37784a880a"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a75c80ae2fd169fcdd8708c37784a880a">logmap_default</a> (const T &amp;l0, const T &amp;lp)</td></tr>
<tr class="memdesc:a75c80ae2fd169fcdd8708c37784a880a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log map centered at l0, s.t.  <a href="#a75c80ae2fd169fcdd8708c37784a880a">More...</a><br/></td></tr>
<tr class="separator:a75c80ae2fd169fcdd8708c37784a880a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0170df6a1f64df845e4445bdf777742"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af0170df6a1f64df845e4445bdf777742"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#af0170df6a1f64df845e4445bdf777742">expmap_default</a> (const T &amp;t, const Vector &amp;d)</td></tr>
<tr class="memdesc:af0170df6a1f64df845e4445bdf777742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponential map centered at l0, s.t.  <a href="#af0170df6a1f64df845e4445bdf777742">More...</a><br/></td></tr>
<tr class="separator:af0170df6a1f64df845e4445bdf777742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd55c711e6ceee791b595558eb3ec8a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adbd55c711e6ceee791b595558eb3ec8a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#adbd55c711e6ceee791b595558eb3ec8a">BCH</a> (const T &amp;X, const T &amp;Y)</td></tr>
<tr class="memdesc:adbd55c711e6ceee791b595558eb3ec8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three term approximation of the Baker�Campbell�Hausdorff formula In non-commutative Lie groups, when composing exp(Z) = exp(X)exp(Y) it is not true that Z = X+Y.  <a href="#adbd55c711e6ceee791b595558eb3ec8a">More...</a><br/></td></tr>
<tr class="separator:adbd55c711e6ceee791b595558eb3ec8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe28b7f8e3592fb9f5cf9ebae09497ba"><td class="memTemplParams" colspan="2"><a class="anchor" id="afe28b7f8e3592fb9f5cf9ebae09497ba"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:afe28b7f8e3592fb9f5cf9ebae09497ba"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#afe28b7f8e3592fb9f5cf9ebae09497ba">wedge</a> (const Vector &amp;x)</td></tr>
<tr class="memdesc:afe28b7f8e3592fb9f5cf9ebae09497ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of wedge (see Murray94book) used to convert from n exponential coordinates to n*n element of the Lie algebra. <br/></td></tr>
<tr class="separator:afe28b7f8e3592fb9f5cf9ebae09497ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3041816208c79ef76d3ef2e0991d90b2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3041816208c79ef76d3ef2e0991d90b2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a3041816208c79ef76d3ef2e0991d90b2">expm</a> (const Vector &amp;x, int K=7)</td></tr>
<tr class="memdesc:a3041816208c79ef76d3ef2e0991d90b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponential map given exponential coordinates class T needs a wedge&lt;&gt; function and a constructor from Matrix.  <a href="#a3041816208c79ef76d3ef2e0991d90b2">More...</a><br/></td></tr>
<tr class="separator:a3041816208c79ef76d3ef2e0991d90b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33240affd7dc54b7a85c6f3136853f7f"><td class="memItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a33240affd7dc54b7a85c6f3136853f7f">zeros</a> (size_t m, size_t n)</td></tr>
<tr class="memdesc:a33240affd7dc54b7a85c6f3136853f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an zeros matrix, with matlab-like syntax.  <a href="#a33240affd7dc54b7a85c6f3136853f7f">More...</a><br/></td></tr>
<tr class="separator:a33240affd7dc54b7a85c6f3136853f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da8a8496d1e82788f239de578581424"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8da8a8496d1e82788f239de578581424"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a8da8a8496d1e82788f239de578581424">ones</a> (size_t m, size_t n)</td></tr>
<tr class="memdesc:a8da8a8496d1e82788f239de578581424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an ones matrix, with matlab-like syntax. <br/></td></tr>
<tr class="separator:a8da8a8496d1e82788f239de578581424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728f2e626412c19fa789a65eaba41819"><td class="memItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a728f2e626412c19fa789a65eaba41819">eye</a> (size_t m, size_t n)</td></tr>
<tr class="memdesc:a728f2e626412c19fa789a65eaba41819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an identity matrix, with matlab-like syntax.  <a href="#a728f2e626412c19fa789a65eaba41819">More...</a><br/></td></tr>
<tr class="separator:a728f2e626412c19fa789a65eaba41819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc9d7205e49e222505860d4a302303f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcc9d7205e49e222505860d4a302303f"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><b>diag</b> (const Vector &amp;v)</td></tr>
<tr class="separator:afcc9d7205e49e222505860d4a302303f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9622226dfe06908f11b42bf0bdd22d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f9622226dfe06908f11b42bf0bdd22d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a3f9622226dfe06908f11b42bf0bdd22d">assert_equal</a> (const Matrix &amp;A, const Matrix &amp;B, double tol=1e-9)</td></tr>
<tr class="memdesc:a3f9622226dfe06908f11b42bf0bdd22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">equals with an tolerance, prints out message if unequal <br/></td></tr>
<tr class="separator:a3f9622226dfe06908f11b42bf0bdd22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a116d0643f123ef3b15d91056506492"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a116d0643f123ef3b15d91056506492"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a7a116d0643f123ef3b15d91056506492">assert_inequal</a> (const Matrix &amp;A, const Matrix &amp;B, double tol=1e-9)</td></tr>
<tr class="memdesc:a7a116d0643f123ef3b15d91056506492"><td class="mdescLeft">&#160;</td><td class="mdescRight">inequals with an tolerance, prints out message if within tolerance <br/></td></tr>
<tr class="separator:a7a116d0643f123ef3b15d91056506492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0e19bbbeaca95843e8161b89a12fda"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb0e19bbbeaca95843e8161b89a12fda"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#abb0e19bbbeaca95843e8161b89a12fda">assert_equal</a> (const std::list&lt; Matrix &gt; &amp;As, const std::list&lt; Matrix &gt; &amp;Bs, double tol=1e-9)</td></tr>
<tr class="memdesc:abb0e19bbbeaca95843e8161b89a12fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">equals with an tolerance, prints out message if unequal <br/></td></tr>
<tr class="separator:abb0e19bbbeaca95843e8161b89a12fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f0349471464c1fb515819d9503849a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8f0349471464c1fb515819d9503849a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ad8f0349471464c1fb515819d9503849a">linear_independent</a> (const Matrix &amp;A, const Matrix &amp;B, double tol=1e-9)</td></tr>
<tr class="memdesc:ad8f0349471464c1fb515819d9503849a"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the rows of two matrices are linear independent <br/></td></tr>
<tr class="separator:ad8f0349471464c1fb515819d9503849a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b81794af72954abafbb726fc712f5db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b81794af72954abafbb726fc712f5db"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a4b81794af72954abafbb726fc712f5db">linear_dependent</a> (const Matrix &amp;A, const Matrix &amp;B, double tol=1e-9)</td></tr>
<tr class="memdesc:a4b81794af72954abafbb726fc712f5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the rows of two matrices are linear dependent <br/></td></tr>
<tr class="separator:a4b81794af72954abafbb726fc712f5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991da8573b30c717bf609e2ff5d0069b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a991da8573b30c717bf609e2ff5d0069b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a991da8573b30c717bf609e2ff5d0069b">multiplyAdd</a> (double alpha, const Matrix &amp;A, const Vector &amp;x, Vector &amp;e)</td></tr>
<tr class="memdesc:a991da8573b30c717bf609e2ff5d0069b"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS Level-2 style e &lt;- e + alpha*A*x. <br/></td></tr>
<tr class="separator:a991da8573b30c717bf609e2ff5d0069b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5119e8b02af1b70c1719b3b79c39769"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5119e8b02af1b70c1719b3b79c39769"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ad5119e8b02af1b70c1719b3b79c39769">multiplyAdd</a> (const Matrix &amp;A, const Vector &amp;x, Vector &amp;e)</td></tr>
<tr class="memdesc:ad5119e8b02af1b70c1719b3b79c39769"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS Level-2 style e &lt;- e + A*x. <br/></td></tr>
<tr class="separator:ad5119e8b02af1b70c1719b3b79c39769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2218e53a2b99c449e70aa5b7805895fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2218e53a2b99c449e70aa5b7805895fc"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a2218e53a2b99c449e70aa5b7805895fc">operator^</a> (const Matrix &amp;A, const Vector &amp;v)</td></tr>
<tr class="memdesc:a2218e53a2b99c449e70aa5b7805895fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload ^ for trans(A)*v We transpose the vectors for speed. <br/></td></tr>
<tr class="separator:a2218e53a2b99c449e70aa5b7805895fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376e4d2e196451babb362c6eb04a7a00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a376e4d2e196451babb362c6eb04a7a00"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a376e4d2e196451babb362c6eb04a7a00">transposeMultiplyAdd</a> (double alpha, const Matrix &amp;A, const Vector &amp;e, Vector &amp;x)</td></tr>
<tr class="memdesc:a376e4d2e196451babb362c6eb04a7a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS Level-2 style x &lt;- x + alpha*A'*e. <br/></td></tr>
<tr class="separator:a376e4d2e196451babb362c6eb04a7a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa038f2f0c136a5c5ca2dcfcc425e9c28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa038f2f0c136a5c5ca2dcfcc425e9c28"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#aa038f2f0c136a5c5ca2dcfcc425e9c28">transposeMultiplyAdd</a> (const Matrix &amp;A, const Vector &amp;e, Vector &amp;x)</td></tr>
<tr class="memdesc:aa038f2f0c136a5c5ca2dcfcc425e9c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS Level-2 style x &lt;- x + A'*e. <br/></td></tr>
<tr class="separator:aa038f2f0c136a5c5ca2dcfcc425e9c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbe1dcc822b54420d461efbbebe3141"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebbe1dcc822b54420d461efbbebe3141"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#aebbe1dcc822b54420d461efbbebe3141">transposeMultiplyAdd</a> (double alpha, const Matrix &amp;A, const Vector &amp;e, SubVector x)</td></tr>
<tr class="memdesc:aebbe1dcc822b54420d461efbbebe3141"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS Level-2 style x &lt;- x + alpha*A'*e. <br/></td></tr>
<tr class="separator:aebbe1dcc822b54420d461efbbebe3141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f7913cd214cdc66d7abb39f8264b24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93f7913cd214cdc66d7abb39f8264b24"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a93f7913cd214cdc66d7abb39f8264b24">print</a> (const Matrix &amp;A, const std::string &amp;s=&quot;&quot;, std::ostream &amp;stream=std::cout)</td></tr>
<tr class="memdesc:a93f7913cd214cdc66d7abb39f8264b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">print a matrix <br/></td></tr>
<tr class="separator:a93f7913cd214cdc66d7abb39f8264b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb7eed9019d3fda8fcf74fbf85b85c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3eb7eed9019d3fda8fcf74fbf85b85c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a3eb7eed9019d3fda8fcf74fbf85b85c9">save</a> (const Matrix &amp;A, const std::string &amp;s, const std::string &amp;filename)</td></tr>
<tr class="memdesc:a3eb7eed9019d3fda8fcf74fbf85b85c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">save a matrix to file, which can be loaded by matlab <br/></td></tr>
<tr class="separator:a3eb7eed9019d3fda8fcf74fbf85b85c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d85957bab2d18cf56ab9aaf95a106de"><td class="memItemLeft" align="right" valign="top">istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a7d85957bab2d18cf56ab9aaf95a106de">operator&gt;&gt;</a> (std::istream &amp;inputStream, Matrix &amp;destinationMatrix)</td></tr>
<tr class="memdesc:a7d85957bab2d18cf56ab9aaf95a106de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a matrix from an input stream, such as a file.  <a href="#a7d85957bab2d18cf56ab9aaf95a106de">More...</a><br/></td></tr>
<tr class="separator:a7d85957bab2d18cf56ab9aaf95a106de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b42c1bd6a8d1152ee1ef86b96526993"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a7b42c1bd6a8d1152ee1ef86b96526993">insertSub</a> (Matrix &amp;fullMatrix, const Matrix &amp;subMatrix, size_t i, size_t j)</td></tr>
<tr class="memdesc:a7b42c1bd6a8d1152ee1ef86b96526993"><td class="mdescLeft">&#160;</td><td class="mdescRight">insert a submatrix IN PLACE at a specified location in a larger matrix NOTE: there is no size checking  <a href="#a7b42c1bd6a8d1152ee1ef86b96526993">More...</a><br/></td></tr>
<tr class="separator:a7b42c1bd6a8d1152ee1ef86b96526993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c32907adce74cf9edd6ee5bba5a085"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1c32907adce74cf9edd6ee5bba5a085"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#af1c32907adce74cf9edd6ee5bba5a085">diag</a> (const std::vector&lt; Matrix &gt; &amp;Hs)</td></tr>
<tr class="memdesc:af1c32907adce74cf9edd6ee5bba5a085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matrix with submatrices along its diagonal. <br/></td></tr>
<tr class="separator:af1c32907adce74cf9edd6ee5bba5a085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8583da4b37aefb1697375402a265c9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ab8583da4b37aefb1697375402a265c9a">insertColumn</a> (Matrix &amp;A, const Vector &amp;col, size_t j)</td></tr>
<tr class="memdesc:ab8583da4b37aefb1697375402a265c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts a column into a matrix IN PLACE NOTE: there is no size checking Alternate form allows for vectors smaller than the whole column to be inserted  <a href="#ab8583da4b37aefb1697375402a265c9a">More...</a><br/></td></tr>
<tr class="separator:ab8583da4b37aefb1697375402a265c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac748fa850cd803d6caf81af3088d96d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac748fa850cd803d6caf81af3088d96d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>insertColumn</b> (Matrix &amp;A, const Vector &amp;col, size_t i, size_t j)</td></tr>
<tr class="separator:ac748fa850cd803d6caf81af3088d96d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7bb98c618c787686109e18a71e87463"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7bb98c618c787686109e18a71e87463"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><b>columnNormSquare</b> (const Matrix &amp;A)</td></tr>
<tr class="separator:ac7bb98c618c787686109e18a71e87463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1feaf381266c4fa007188c663aa733fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1feaf381266c4fa007188c663aa733fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a1feaf381266c4fa007188c663aa733fa">solve</a> (Matrix &amp;A, Matrix &amp;B)</td></tr>
<tr class="memdesc:a1feaf381266c4fa007188c663aa733fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">solve AX=B via in-place Lu factorization and backsubstitution After calling, A contains LU, B the solved RHS vectors <br/></td></tr>
<tr class="separator:a1feaf381266c4fa007188c663aa733fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569422c152fe1a6d49e349cb2ec1aa5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a569422c152fe1a6d49e349cb2ec1aa5e"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a569422c152fe1a6d49e349cb2ec1aa5e">inverse</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a569422c152fe1a6d49e349cb2ec1aa5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">invert A <br/></td></tr>
<tr class="separator:a569422c152fe1a6d49e349cb2ec1aa5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32c295e2c40c1e85f146a8a6266eaa8"><td class="memItemLeft" align="right" valign="top">pair&lt; Matrix, Matrix &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ae32c295e2c40c1e85f146a8a6266eaa8">qr</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:ae32c295e2c40c1e85f146a8a6266eaa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Householder QR factorization, Golub &amp; Van Loan p 224, explicit version.  <a href="#ae32c295e2c40c1e85f146a8a6266eaa8">More...</a><br/></td></tr>
<tr class="separator:ae32c295e2c40c1e85f146a8a6266eaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60019a03f26b92c6b2a08e43d153d4c0"><td class="memItemLeft" align="right" valign="top">list&lt; boost::tuple&lt; Vector, <br class="typebreak"/>
double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a60019a03f26b92c6b2a08e43d153d4c0">weighted_eliminate</a> (Matrix &amp;A, Vector &amp;b, const Vector &amp;sigmas)</td></tr>
<tr class="memdesc:a60019a03f26b92c6b2a08e43d153d4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imperative algorithm for in-place full elimination with weights and constraint handling.  <a href="#a60019a03f26b92c6b2a08e43d153d4c0">More...</a><br/></td></tr>
<tr class="separator:a60019a03f26b92c6b2a08e43d153d4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd1ab05e8ac90b340fbd8f3b322dc6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#abdd1ab05e8ac90b340fbd8f3b322dc6d">householder_</a> (Matrix &amp;A, size_t k, bool copy_vectors)</td></tr>
<tr class="memdesc:abdd1ab05e8ac90b340fbd8f3b322dc6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imperative version of Householder QR factorization, Golub &amp; Van Loan p 224 version with Householder vectors below diagonal, as in GVL.  <a href="#abdd1ab05e8ac90b340fbd8f3b322dc6d">More...</a><br/></td></tr>
<tr class="separator:abdd1ab05e8ac90b340fbd8f3b322dc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7baa2f3184a444adce108633c0265e0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a7baa2f3184a444adce108633c0265e0c">householder</a> (Matrix &amp;A, size_t k)</td></tr>
<tr class="memdesc:a7baa2f3184a444adce108633c0265e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Householder tranformation, zeros below diagonal.  <a href="#a7baa2f3184a444adce108633c0265e0c">More...</a><br/></td></tr>
<tr class="separator:a7baa2f3184a444adce108633c0265e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d998e1b770c9864946ddb031b1c4522"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a0d998e1b770c9864946ddb031b1c4522">backSubstituteLower</a> (const Matrix &amp;L, const Vector &amp;b, bool unit=false)</td></tr>
<tr class="memdesc:a0d998e1b770c9864946ddb031b1c4522"><td class="mdescLeft">&#160;</td><td class="mdescRight">backSubstitute L*x=b  <a href="#a0d998e1b770c9864946ddb031b1c4522">More...</a><br/></td></tr>
<tr class="separator:a0d998e1b770c9864946ddb031b1c4522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4876cbe85d5651a52eda0e97c60f2f"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a6c4876cbe85d5651a52eda0e97c60f2f">backSubstituteUpper</a> (const Matrix &amp;U, const Vector &amp;b, bool unit=false)</td></tr>
<tr class="memdesc:a6c4876cbe85d5651a52eda0e97c60f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">backSubstitute U*x=b  <a href="#a6c4876cbe85d5651a52eda0e97c60f2f">More...</a><br/></td></tr>
<tr class="separator:a6c4876cbe85d5651a52eda0e97c60f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0bf332d52b333dab2b20d763c8925b"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a8b0bf332d52b333dab2b20d763c8925b">backSubstituteUpper</a> (const Vector &amp;b, const Matrix &amp;U, bool unit=false)</td></tr>
<tr class="memdesc:a8b0bf332d52b333dab2b20d763c8925b"><td class="mdescLeft">&#160;</td><td class="mdescRight">backSubstitute x'*U=b'  <a href="#a8b0bf332d52b333dab2b20d763c8925b">More...</a><br/></td></tr>
<tr class="separator:a8b0bf332d52b333dab2b20d763c8925b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c82884a356ddd09229a5283aed04df9"><td class="memItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a5c82884a356ddd09229a5283aed04df9">stack</a> (size_t nrMatrices,...)</td></tr>
<tr class="memdesc:a5c82884a356ddd09229a5283aed04df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a matrix by stacking other matrices Given a set of matrices: A1, A2, A3...  <a href="#a5c82884a356ddd09229a5283aed04df9">More...</a><br/></td></tr>
<tr class="separator:a5c82884a356ddd09229a5283aed04df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952843d658e0425fda99f14f408760ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a952843d658e0425fda99f14f408760ca"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><b>stack</b> (const std::vector&lt; Matrix &gt; &amp;blocks)</td></tr>
<tr class="separator:a952843d658e0425fda99f14f408760ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b524ba6c9aed0d21a020999c9b5d88"><td class="memItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ad8b524ba6c9aed0d21a020999c9b5d88">collect</a> (const std::vector&lt; const Matrix * &gt; &amp;matrices, size_t m=0, size_t n=0)</td></tr>
<tr class="memdesc:ad8b524ba6c9aed0d21a020999c9b5d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a matrix by concatenating Given a set of matrices: A1, A2, A3...  <a href="#ad8b524ba6c9aed0d21a020999c9b5d88">More...</a><br/></td></tr>
<tr class="separator:ad8b524ba6c9aed0d21a020999c9b5d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71fc8eaea5f380a91bcfc1e8b140522"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac71fc8eaea5f380a91bcfc1e8b140522"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><b>collect</b> (size_t nrMatrices,...)</td></tr>
<tr class="separator:ac71fc8eaea5f380a91bcfc1e8b140522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d3ad0252f91f0ec301593c45cf5af7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a24d3ad0252f91f0ec301593c45cf5af7">vector_scale_inplace</a> (const Vector &amp;v, Matrix &amp;A, bool inf_mask=false)</td></tr>
<tr class="memdesc:a24d3ad0252f91f0ec301593c45cf5af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">scales a matrix row or column by the values in a vector Arguments (Matrix, Vector) scales the columns, (Vector, Matrix) scales the rows  <a href="#a24d3ad0252f91f0ec301593c45cf5af7">More...</a><br/></td></tr>
<tr class="separator:a24d3ad0252f91f0ec301593c45cf5af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc4f0fb9712cc419aa8ff8b6d8fe407"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bc4f0fb9712cc419aa8ff8b6d8fe407"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><b>vector_scale</b> (const Vector &amp;v, const Matrix &amp;A, bool inf_mask)</td></tr>
<tr class="separator:a5bc4f0fb9712cc419aa8ff8b6d8fe407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cd7ba6f30e1e9cf47239535630c7c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67cd7ba6f30e1e9cf47239535630c7c6"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><b>vector_scale</b> (const Matrix &amp;A, const Vector &amp;v, bool inf_mask)</td></tr>
<tr class="separator:a67cd7ba6f30e1e9cf47239535630c7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bc5c23cdae085b88d12056c7411463"><td class="memItemLeft" align="right" valign="top">Matrix3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a60bc5c23cdae085b88d12056c7411463">skewSymmetric</a> (double wx, double wy, double wz)</td></tr>
<tr class="memdesc:a60bc5c23cdae085b88d12056c7411463"><td class="mdescLeft">&#160;</td><td class="mdescRight">skew symmetric matrix returns this: 0 -wz wy wz 0 -wx -wy wx 0  <a href="#a60bc5c23cdae085b88d12056c7411463">More...</a><br/></td></tr>
<tr class="separator:a60bc5c23cdae085b88d12056c7411463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d6f844b3fc9874c46f1a753aa03489"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60d6f844b3fc9874c46f1a753aa03489"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a60d6f844b3fc9874c46f1a753aa03489">LLt</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a60d6f844b3fc9874c46f1a753aa03489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the LL^t decomposition of a S.P.D matrix. <br/></td></tr>
<tr class="separator:a60d6f844b3fc9874c46f1a753aa03489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b05b69489f07d74d392d6abf17c644c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b05b69489f07d74d392d6abf17c644c"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a2b05b69489f07d74d392d6abf17c644c">RtR</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a2b05b69489f07d74d392d6abf17c644c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the R^tR decomposition of a S.P.D matrix. <br/></td></tr>
<tr class="separator:a2b05b69489f07d74d392d6abf17c644c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba542e2cd85f08b76f80a0871a4ea713"><td class="memItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#aba542e2cd85f08b76f80a0871a4ea713">cholesky_inverse</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:aba542e2cd85f08b76f80a0871a4ea713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the inverse of a S.P.D.  <a href="#aba542e2cd85f08b76f80a0871a4ea713">More...</a><br/></td></tr>
<tr class="separator:aba542e2cd85f08b76f80a0871a4ea713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff78dee59ac0250432081f39deb5f6d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff78dee59ac0250432081f39deb5f6d1"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#aff78dee59ac0250432081f39deb5f6d1">inverse_square_root</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:aff78dee59ac0250432081f39deb5f6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Cholesky to calculate inverse square root of a matrix. <br/></td></tr>
<tr class="separator:aff78dee59ac0250432081f39deb5f6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7e46204d953f64a39445599dbd7eee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a8d7e46204d953f64a39445599dbd7eee">svd</a> (const Matrix &amp;A, Matrix &amp;U, Vector &amp;S, Matrix &amp;V)</td></tr>
<tr class="memdesc:a8d7e46204d953f64a39445599dbd7eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">SVD computes economy SVD A=U*S*V'.  <a href="#a8d7e46204d953f64a39445599dbd7eee">More...</a><br/></td></tr>
<tr class="separator:a8d7e46204d953f64a39445599dbd7eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c65f1a69009a306b6a5f9ef31dcee2"><td class="memItemLeft" align="right" valign="top">boost::tuple&lt; int, double, Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ab2c65f1a69009a306b6a5f9ef31dcee2">DLT</a> (const Matrix &amp;A, double rank_tol=1e-9)</td></tr>
<tr class="memdesc:ab2c65f1a69009a306b6a5f9ef31dcee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct linear transform algorithm that calls svd to find a vector v that minimizes the algebraic error A*v.  <a href="#ab2c65f1a69009a306b6a5f9ef31dcee2">More...</a><br/></td></tr>
<tr class="separator:ab2c65f1a69009a306b6a5f9ef31dcee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15462d8c16813d0a7a5b1f76a2f64b7"><td class="memItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ab15462d8c16813d0a7a5b1f76a2f64b7">expm</a> (const Matrix &amp;A, size_t K=7)</td></tr>
<tr class="memdesc:ab15462d8c16813d0a7a5b1f76a2f64b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical exponential map, naive approach, not industrial strength !!!  <a href="#ab15462d8c16813d0a7a5b1f76a2f64b7">More...</a><br/></td></tr>
<tr class="separator:ab15462d8c16813d0a7a5b1f76a2f64b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d760d40eb1c3e3e214bcb853e488e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83d760d40eb1c3e3e214bcb853e488e0"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a83d760d40eb1c3e3e214bcb853e488e0">Cayley</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:a83d760d40eb1c3e3e214bcb853e488e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cayley transform. <br/></td></tr>
<tr class="separator:a83d760d40eb1c3e3e214bcb853e488e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1beb274aff9f803d65219200078e7310"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1beb274aff9f803d65219200078e7310"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>formatMatrixIndented</b> (const std::string &amp;label, const Matrix &amp;matrix, bool makeVectorHorizontal)</td></tr>
<tr class="separator:a1beb274aff9f803d65219200078e7310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae683ac9fd3c4679ddde00872d37f0975"><td class="memItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ae683ac9fd3c4679ddde00872d37f0975">eye</a> (size_t m)</td></tr>
<tr class="memdesc:ae683ac9fd3c4679ddde00872d37f0975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a square identity matrix, with matlab-like syntax.  <a href="#ae683ac9fd3c4679ddde00872d37f0975">More...</a><br/></td></tr>
<tr class="separator:ae683ac9fd3c4679ddde00872d37f0975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31e657258505b2e5148846ebbaa3195"><td class="memTemplParams" colspan="2"><a class="anchor" id="af31e657258505b2e5148846ebbaa3195"></a>
template&lt;class MATRIX &gt; </td></tr>
<tr class="memitem:af31e657258505b2e5148846ebbaa3195"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#af31e657258505b2e5148846ebbaa3195">equal_with_abs_tol</a> (const Eigen::DenseBase&lt; MATRIX &gt; &amp;A, const Eigen::DenseBase&lt; MATRIX &gt; &amp;B, double tol=1e-9)</td></tr>
<tr class="memdesc:af31e657258505b2e5148846ebbaa3195"><td class="mdescLeft">&#160;</td><td class="mdescRight">equals with an tolerance <br/></td></tr>
<tr class="separator:af31e657258505b2e5148846ebbaa3195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5b3cf3f54adcbdd6d9e7403f1a792f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd5b3cf3f54adcbdd6d9e7403f1a792f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#afd5b3cf3f54adcbdd6d9e7403f1a792f">operator==</a> (const Matrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:afd5b3cf3f54adcbdd6d9e7403f1a792f"><td class="mdescLeft">&#160;</td><td class="mdescRight">equality is just equal_with_abs_tol 1e-9 <br/></td></tr>
<tr class="separator:afd5b3cf3f54adcbdd6d9e7403f1a792f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab235abf7505b634be2165e0db58239dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab235abf7505b634be2165e0db58239dd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ab235abf7505b634be2165e0db58239dd">operator!=</a> (const Matrix &amp;A, const Matrix &amp;B)</td></tr>
<tr class="memdesc:ab235abf7505b634be2165e0db58239dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">inequality <br/></td></tr>
<tr class="separator:ab235abf7505b634be2165e0db58239dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc29e3164ed30e785a3c48dfd1aa6ca5"><td class="memTemplParams" colspan="2"><a class="anchor" id="abc29e3164ed30e785a3c48dfd1aa6ca5"></a>
template&lt;class MATRIX &gt; </td></tr>
<tr class="memitem:abc29e3164ed30e785a3c48dfd1aa6ca5"><td class="memTemplItemLeft" align="right" valign="top">MATRIX&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#abc29e3164ed30e785a3c48dfd1aa6ca5">prod</a> (const MATRIX &amp;A, const MATRIX &amp;B)</td></tr>
<tr class="memdesc:abc29e3164ed30e785a3c48dfd1aa6ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">products using old-style format to improve compatibility <br/></td></tr>
<tr class="separator:abc29e3164ed30e785a3c48dfd1aa6ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6673ca73bb7ab59f46f08e3a5cc284"><td class="memTemplParams" colspan="2">template&lt;class MATRIX &gt; </td></tr>
<tr class="memitem:aed6673ca73bb7ab59f46f08e3a5cc284"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Block&lt; const MATRIX &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#aed6673ca73bb7ab59f46f08e3a5cc284">sub</a> (const MATRIX &amp;A, size_t i1, size_t i2, size_t j1, size_t j2)</td></tr>
<tr class="memdesc:aed6673ca73bb7ab59f46f08e3a5cc284"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract submatrix, slice semantics, i.e.  <a href="#aed6673ca73bb7ab59f46f08e3a5cc284">More...</a><br/></td></tr>
<tr class="separator:aed6673ca73bb7ab59f46f08e3a5cc284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a559dba69e2854eb66e34222f60f55722"><td class="memTemplParams" colspan="2">template&lt;class MATRIX &gt; </td></tr>
<tr class="memitem:a559dba69e2854eb66e34222f60f55722"><td class="memTemplItemLeft" align="right" valign="top">const MATRIX::ConstColXpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a559dba69e2854eb66e34222f60f55722">column</a> (const MATRIX &amp;A, size_t j)</td></tr>
<tr class="memdesc:a559dba69e2854eb66e34222f60f55722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a column view from a matrix that avoids a copy.  <a href="#a559dba69e2854eb66e34222f60f55722">More...</a><br/></td></tr>
<tr class="separator:a559dba69e2854eb66e34222f60f55722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2754f325c8600303d627d9e8cf1f9949"><td class="memTemplParams" colspan="2">template&lt;class MATRIX &gt; </td></tr>
<tr class="memitem:a2754f325c8600303d627d9e8cf1f9949"><td class="memTemplItemLeft" align="right" valign="top">const MATRIX::ConstRowXpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a2754f325c8600303d627d9e8cf1f9949">row</a> (const MATRIX &amp;A, size_t j)</td></tr>
<tr class="memdesc:a2754f325c8600303d627d9e8cf1f9949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a row view from a matrix that avoids a copy.  <a href="#a2754f325c8600303d627d9e8cf1f9949">More...</a><br/></td></tr>
<tr class="separator:a2754f325c8600303d627d9e8cf1f9949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57edf6ed7312f63d35f73233665c334d"><td class="memTemplParams" colspan="2">template&lt;class MATRIX &gt; </td></tr>
<tr class="memitem:a57edf6ed7312f63d35f73233665c334d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a57edf6ed7312f63d35f73233665c334d">zeroBelowDiagonal</a> (MATRIX &amp;A, size_t cols=0)</td></tr>
<tr class="memdesc:a57edf6ed7312f63d35f73233665c334d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zeros all of the elements below the diagonal of a matrix, in place.  <a href="#a57edf6ed7312f63d35f73233665c334d">More...</a><br/></td></tr>
<tr class="separator:a57edf6ed7312f63d35f73233665c334d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e36d7ab63000feddaeb61bbfcf2db1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2e36d7ab63000feddaeb61bbfcf2db1"></a>
Matrix&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#aa2e36d7ab63000feddaeb61bbfcf2db1">trans</a> (const Matrix &amp;A)</td></tr>
<tr class="memdesc:aa2e36d7ab63000feddaeb61bbfcf2db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">static transpose function, just calls Eigen transpose member function <br/></td></tr>
<tr class="separator:aa2e36d7ab63000feddaeb61bbfcf2db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc9a38f15c24872e82b504fa9761340"><td class="memTemplParams" colspan="2">template&lt;class MATRIX &gt; </td></tr>
<tr class="memitem:a1dc9a38f15c24872e82b504fa9761340"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a1dc9a38f15c24872e82b504fa9761340">inplace_QR</a> (MATRIX &amp;A)</td></tr>
<tr class="memdesc:a1dc9a38f15c24872e82b504fa9761340"><td class="mdescLeft">&#160;</td><td class="mdescRight">QR factorization using Eigen's internal block QR algorithm.  <a href="#a1dc9a38f15c24872e82b504fa9761340">More...</a><br/></td></tr>
<tr class="separator:a1dc9a38f15c24872e82b504fa9761340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699b5cddc5e7e10eb543c57a728a8b4b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a699b5cddc5e7e10eb543c57a728a8b4b"></a>
template&lt;class Derived &gt; </td></tr>
<tr class="memitem:a699b5cddc5e7e10eb543c57a728a8b4b"><td class="memTemplItemLeft" align="right" valign="top">Matrix3&#160;</td><td class="memTemplItemRight" valign="bottom"><b>skewSymmetric</b> (const Eigen::MatrixBase&lt; Derived &gt; &amp;w)</td></tr>
<tr class="separator:a699b5cddc5e7e10eb543c57a728a8b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d18623b1b79e06fb05a73e609b89c3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a21d18623b1b79e06fb05a73e609b89c3"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a21d18623b1b79e06fb05a73e609b89c3"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, N, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a21d18623b1b79e06fb05a73e609b89c3">Cayley</a> (const Eigen::Matrix&lt; double, N, N &gt; &amp;A)</td></tr>
<tr class="memdesc:a21d18623b1b79e06fb05a73e609b89c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Cayley transform using fixed size matrices to let Eigen do more optimization. <br/></td></tr>
<tr class="separator:a21d18623b1b79e06fb05a73e609b89c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7633e808bfb81359f2bef2fde0a81ce3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7633e808bfb81359f2bef2fde0a81ce3"></a>
<a class="el" href="a00152.html">LieVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a7633e808bfb81359f2bef2fde0a81ce3">makeLieVector</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:a7633e808bfb81359f2bef2fde0a81ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">global functions for converting to a <a class="el" href="a00152.html" title="LieVector is a wrapper around vector to allow it to be a Lie type.">LieVector</a> for use with numericalDerivative <br/></td></tr>
<tr class="separator:a7633e808bfb81359f2bef2fde0a81ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa93f41b5b8a3a701c0ca3322d2c6818"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa93f41b5b8a3a701c0ca3322d2c6818"></a>
<a class="el" href="a00152.html">LieVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>makeLieVectorD</b> (double d)</td></tr>
<tr class="separator:aaa93f41b5b8a3a701c0ca3322d2c6818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1beb78285325fde6182c86eb18ae2eb"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac1beb78285325fde6182c86eb18ae2eb"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:ac1beb78285325fde6182c86eb18ae2eb"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#ac1beb78285325fde6182c86eb18ae2eb">numericalGradient</a> (boost::function&lt; double(const X &amp;)&gt; h, const X &amp;x, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:ac1beb78285325fde6182c86eb18ae2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerically compute gradient of scalar function Class X is the input argument The class X needs to have dim, expmap, logmap. <br/></td></tr>
<tr class="separator:ac1beb78285325fde6182c86eb18ae2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d310374003f3fec5b618b129c8cc21"><td class="memTemplParams" colspan="2"><a class="anchor" id="a52d310374003f3fec5b618b129c8cc21"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:a52d310374003f3fec5b618b129c8cc21"><td class="memTemplItemLeft" align="right" valign="top">Vector&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalGradient</b> (double(*h)(const X &amp;), const X &amp;x, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:a52d310374003f3fec5b618b129c8cc21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168905f3fbaf00610d4dc486bcc4365b"><td class="memTemplParams" colspan="2">template&lt;class Y , class X &gt; </td></tr>
<tr class="memitem:a168905f3fbaf00610d4dc486bcc4365b"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a168905f3fbaf00610d4dc486bcc4365b">numericalDerivative11</a> (boost::function&lt; Y(const X &amp;)&gt; h, const X &amp;x, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a168905f3fbaf00610d4dc486bcc4365b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 1 of unary function.  <a href="#a168905f3fbaf00610d4dc486bcc4365b">More...</a><br/></td></tr>
<tr class="separator:a168905f3fbaf00610d4dc486bcc4365b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b375fb6b8c69d2cfbf9f1d132464a0c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3b375fb6b8c69d2cfbf9f1d132464a0c"></a>
template&lt;class Y , class X &gt; </td></tr>
<tr class="memitem:a3b375fb6b8c69d2cfbf9f1d132464a0c"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a3b375fb6b8c69d2cfbf9f1d132464a0c">numericalDerivative11</a> (Y(*h)(const X &amp;), const X &amp;x, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a3b375fb6b8c69d2cfbf9f1d132464a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">use a raw C++ function pointer <br/></td></tr>
<tr class="separator:a3b375fb6b8c69d2cfbf9f1d132464a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe4866aa69f0146c6af20f60bc69ddb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6fe4866aa69f0146c6af20f60bc69ddb"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:a6fe4866aa69f0146c6af20f60bc69ddb"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a6fe4866aa69f0146c6af20f60bc69ddb">numericalDerivative11</a> (double(*h)(const X &amp;), const X &amp;x, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a6fe4866aa69f0146c6af20f60bc69ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">remapping for double valued functions <br/></td></tr>
<tr class="separator:a6fe4866aa69f0146c6af20f60bc69ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f5c58b0716833841299b1f10def7a7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a57f5c58b0716833841299b1f10def7a7"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:a57f5c58b0716833841299b1f10def7a7"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a57f5c58b0716833841299b1f10def7a7">numericalDerivative11</a> (boost::function&lt; Vector(const X &amp;)&gt; h, const X &amp;x, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a57f5c58b0716833841299b1f10def7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">remapping for vector valued functions <br/></td></tr>
<tr class="separator:a57f5c58b0716833841299b1f10def7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5ee7979792a1055f578b9f9de103dc"><td class="memTemplParams" colspan="2"><a class="anchor" id="abb5ee7979792a1055f578b9f9de103dc"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:abb5ee7979792a1055f578b9f9de103dc"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative11</b> (Vector(*h)(const X &amp;), const X &amp;x, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:abb5ee7979792a1055f578b9f9de103dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaaad2ac19febd86f2afa7c6916659b9"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 &gt; </td></tr>
<tr class="memitem:aeaaad2ac19febd86f2afa7c6916659b9"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#aeaaad2ac19febd86f2afa7c6916659b9">numericalDerivative21</a> (boost::function&lt; Y(const X1 &amp;, const X2 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:aeaaad2ac19febd86f2afa7c6916659b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 1 of binary function.  <a href="#aeaaad2ac19febd86f2afa7c6916659b9">More...</a><br/></td></tr>
<tr class="separator:aeaaad2ac19febd86f2afa7c6916659b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9714f8cdfe7a86a48d7791b80891fbb3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9714f8cdfe7a86a48d7791b80891fbb3"></a>
template&lt;class Y , class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a9714f8cdfe7a86a48d7791b80891fbb3"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a9714f8cdfe7a86a48d7791b80891fbb3">numericalDerivative21</a> (Y(*h)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a9714f8cdfe7a86a48d7791b80891fbb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">use a raw C++ function pointer <br/></td></tr>
<tr class="separator:a9714f8cdfe7a86a48d7791b80891fbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53aecd57c15f4263e261d40ebb91ce16"><td class="memTemplParams" colspan="2"><a class="anchor" id="a53aecd57c15f4263e261d40ebb91ce16"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a53aecd57c15f4263e261d40ebb91ce16"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a53aecd57c15f4263e261d40ebb91ce16">numericalDerivative21</a> (boost::function&lt; double(const X1 &amp;, const X2 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a53aecd57c15f4263e261d40ebb91ce16"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo-partial template specialization for double return values <br/></td></tr>
<tr class="separator:a53aecd57c15f4263e261d40ebb91ce16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c798b6a7489350b8a57803db51ede1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a28c798b6a7489350b8a57803db51ede1"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a28c798b6a7489350b8a57803db51ede1"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative21</b> (double(*h)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:a28c798b6a7489350b8a57803db51ede1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b328b8c696bf16801ac833efbfe2d7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a79b328b8c696bf16801ac833efbfe2d7"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a79b328b8c696bf16801ac833efbfe2d7"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a79b328b8c696bf16801ac833efbfe2d7">numericalDerivative21</a> (boost::function&lt; Vector(const X1 &amp;, const X2 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a79b328b8c696bf16801ac833efbfe2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo-partial template specialization for vector return values <br/></td></tr>
<tr class="separator:a79b328b8c696bf16801ac833efbfe2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac044fe197ee3e237f0fdd8a57d9ab2cc"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac044fe197ee3e237f0fdd8a57d9ab2cc"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:ac044fe197ee3e237f0fdd8a57d9ab2cc"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative21</b> (Vector(*h)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:ac044fe197ee3e237f0fdd8a57d9ab2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad054ef564f08a62522b456cf677502a8"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 &gt; </td></tr>
<tr class="memitem:ad054ef564f08a62522b456cf677502a8"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#ad054ef564f08a62522b456cf677502a8">numericalDerivative22</a> (boost::function&lt; Y(const X1 &amp;, const X2 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:ad054ef564f08a62522b456cf677502a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 2 of binary function.  <a href="#ad054ef564f08a62522b456cf677502a8">More...</a><br/></td></tr>
<tr class="separator:ad054ef564f08a62522b456cf677502a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ba223711d4313a98d5d6bf1cb3bb50"><td class="memTemplParams" colspan="2"><a class="anchor" id="a60ba223711d4313a98d5d6bf1cb3bb50"></a>
template&lt;class Y , class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a60ba223711d4313a98d5d6bf1cb3bb50"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a60ba223711d4313a98d5d6bf1cb3bb50">numericalDerivative22</a> (Y(*h)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a60ba223711d4313a98d5d6bf1cb3bb50"><td class="mdescLeft">&#160;</td><td class="mdescRight">use a raw C++ function pointer <br/></td></tr>
<tr class="separator:a60ba223711d4313a98d5d6bf1cb3bb50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac6b4100f0ceb05aabb839e43eaf801"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5ac6b4100f0ceb05aabb839e43eaf801"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a5ac6b4100f0ceb05aabb839e43eaf801"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a5ac6b4100f0ceb05aabb839e43eaf801">numericalDerivative22</a> (boost::function&lt; double(const X1 &amp;, const X2 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a5ac6b4100f0ceb05aabb839e43eaf801"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo-partial template specialization for double return values <br/></td></tr>
<tr class="separator:a5ac6b4100f0ceb05aabb839e43eaf801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0dff8d7fa549c1af1962382d4f51a5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3e0dff8d7fa549c1af1962382d4f51a5"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a3e0dff8d7fa549c1af1962382d4f51a5"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative22</b> (double(*h)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:a3e0dff8d7fa549c1af1962382d4f51a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aac9371e141372ece47a166850ebf8b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9aac9371e141372ece47a166850ebf8b"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a9aac9371e141372ece47a166850ebf8b"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a9aac9371e141372ece47a166850ebf8b">numericalDerivative22</a> (boost::function&lt; Vector(const X1 &amp;, const X2 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a9aac9371e141372ece47a166850ebf8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo-partial template specialization for vector return values <br/></td></tr>
<tr class="separator:a9aac9371e141372ece47a166850ebf8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a29e4a4726a270e36395d2ee79350d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae3a29e4a4726a270e36395d2ee79350d"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:ae3a29e4a4726a270e36395d2ee79350d"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative22</b> (Vector(*h)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:ae3a29e4a4726a270e36395d2ee79350d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cefcc2e690755b40d84f04beb123ea"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:af6cefcc2e690755b40d84f04beb123ea"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#af6cefcc2e690755b40d84f04beb123ea">numericalDerivative31</a> (boost::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:af6cefcc2e690755b40d84f04beb123ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 1 of ternary function.  <a href="#af6cefcc2e690755b40d84f04beb123ea">More...</a><br/></td></tr>
<tr class="separator:af6cefcc2e690755b40d84f04beb123ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b0f07ac2b1b629ccc8b106a924bf5d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a42b0f07ac2b1b629ccc8b106a924bf5d"></a>
template&lt;class Y , class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a42b0f07ac2b1b629ccc8b106a924bf5d"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative31</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:a42b0f07ac2b1b629ccc8b106a924bf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ff733799ed93622a896fea47eeef62"><td class="memTemplParams" colspan="2"><a class="anchor" id="a49ff733799ed93622a896fea47eeef62"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a49ff733799ed93622a896fea47eeef62"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a49ff733799ed93622a896fea47eeef62">numericalDerivative31</a> (boost::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a49ff733799ed93622a896fea47eeef62"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo-partial template specialization for double return values <br/></td></tr>
<tr class="separator:a49ff733799ed93622a896fea47eeef62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60341eefc0af912a79e003444e92cd5d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a60341eefc0af912a79e003444e92cd5d"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a60341eefc0af912a79e003444e92cd5d"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative31</b> (double(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:a60341eefc0af912a79e003444e92cd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1151b40cc04229cfeb05e2b226189446"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1151b40cc04229cfeb05e2b226189446"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a1151b40cc04229cfeb05e2b226189446"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a1151b40cc04229cfeb05e2b226189446">numericalDerivative31</a> (boost::function&lt; Vector(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a1151b40cc04229cfeb05e2b226189446"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo-partial template specialization for vector return values <br/></td></tr>
<tr class="separator:a1151b40cc04229cfeb05e2b226189446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834cf2d4648127f7cbaac7331ba49f88"><td class="memTemplParams" colspan="2"><a class="anchor" id="a834cf2d4648127f7cbaac7331ba49f88"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a834cf2d4648127f7cbaac7331ba49f88"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative31</b> (Vector(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:a834cf2d4648127f7cbaac7331ba49f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4fe49c0dea74639a95bfb58e21e663"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a0b4fe49c0dea74639a95bfb58e21e663"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a0b4fe49c0dea74639a95bfb58e21e663">numericalDerivative32</a> (boost::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a0b4fe49c0dea74639a95bfb58e21e663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 2 of ternary function.  <a href="#a0b4fe49c0dea74639a95bfb58e21e663">More...</a><br/></td></tr>
<tr class="separator:a0b4fe49c0dea74639a95bfb58e21e663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a1820eeacd9a217d922ae731e2b3c1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad3a1820eeacd9a217d922ae731e2b3c1"></a>
template&lt;class Y , class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:ad3a1820eeacd9a217d922ae731e2b3c1"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative32</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:ad3a1820eeacd9a217d922ae731e2b3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40d267127fa96699dc26c27a11d4e87"><td class="memTemplParams" colspan="2"><a class="anchor" id="af40d267127fa96699dc26c27a11d4e87"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:af40d267127fa96699dc26c27a11d4e87"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#af40d267127fa96699dc26c27a11d4e87">numericalDerivative32</a> (boost::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:af40d267127fa96699dc26c27a11d4e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo-partial template specialization for double return values <br/></td></tr>
<tr class="separator:af40d267127fa96699dc26c27a11d4e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8ab5de702d754bc646dc39b75f38e1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2c8ab5de702d754bc646dc39b75f38e1"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a2c8ab5de702d754bc646dc39b75f38e1"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative32</b> (double(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:a2c8ab5de702d754bc646dc39b75f38e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cea897ac1b1b5ccbdd0825167ed057c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8cea897ac1b1b5ccbdd0825167ed057c"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a8cea897ac1b1b5ccbdd0825167ed057c"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a8cea897ac1b1b5ccbdd0825167ed057c">numericalDerivative32</a> (boost::function&lt; Vector(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a8cea897ac1b1b5ccbdd0825167ed057c"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo-partial template specialization for vector return values <br/></td></tr>
<tr class="separator:a8cea897ac1b1b5ccbdd0825167ed057c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fd3c53635d94771e6f5c874664cff4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac2fd3c53635d94771e6f5c874664cff4"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:ac2fd3c53635d94771e6f5c874664cff4"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative32</b> (Vector(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:ac2fd3c53635d94771e6f5c874664cff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5def64a08dde6bc660af18e22f69e901"><td class="memTemplParams" colspan="2">template&lt;class Y , class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a5def64a08dde6bc660af18e22f69e901"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a5def64a08dde6bc660af18e22f69e901">numericalDerivative33</a> (boost::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a5def64a08dde6bc660af18e22f69e901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical derivative in argument 3 of ternary function.  <a href="#a5def64a08dde6bc660af18e22f69e901">More...</a><br/></td></tr>
<tr class="separator:a5def64a08dde6bc660af18e22f69e901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732a2a9a5a4b3c8135e1468a0e676904"><td class="memTemplParams" colspan="2"><a class="anchor" id="a732a2a9a5a4b3c8135e1468a0e676904"></a>
template&lt;class Y , class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a732a2a9a5a4b3c8135e1468a0e676904"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative33</b> (Y(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:a732a2a9a5a4b3c8135e1468a0e676904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8fc2cab4819a3df2a7730072cf37a1d"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa8fc2cab4819a3df2a7730072cf37a1d"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:aa8fc2cab4819a3df2a7730072cf37a1d"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#aa8fc2cab4819a3df2a7730072cf37a1d">numericalDerivative33</a> (boost::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:aa8fc2cab4819a3df2a7730072cf37a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo-partial template specialization for double return values <br/></td></tr>
<tr class="separator:aa8fc2cab4819a3df2a7730072cf37a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ee23fac2c8efd5cd50b5ca0a379ee1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a57ee23fac2c8efd5cd50b5ca0a379ee1"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a57ee23fac2c8efd5cd50b5ca0a379ee1"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative33</b> (double(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:a57ee23fac2c8efd5cd50b5ca0a379ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa265046959ca82909006caa5b2eda199"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa265046959ca82909006caa5b2eda199"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:aa265046959ca82909006caa5b2eda199"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#aa265046959ca82909006caa5b2eda199">numericalDerivative33</a> (boost::function&lt; Vector(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; h, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:aa265046959ca82909006caa5b2eda199"><td class="mdescLeft">&#160;</td><td class="mdescRight">pseudo-partial template specialization for vector return values <br/></td></tr>
<tr class="separator:aa265046959ca82909006caa5b2eda199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93115f439799b0f1190c704c50df63e6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a93115f439799b0f1190c704c50df63e6"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a93115f439799b0f1190c704c50df63e6"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalDerivative33</b> (Vector(*h)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:a93115f439799b0f1190c704c50df63e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dc11c40862fe22c0ebab881edda95a"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a11dc11c40862fe22c0ebab881edda95a"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a11dc11c40862fe22c0ebab881edda95a">numericalHessian</a> (boost::function&lt; double(const X &amp;)&gt; f, const X &amp;x, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:a11dc11c40862fe22c0ebab881edda95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute numerical Hessian matrix.  <a href="#a11dc11c40862fe22c0ebab881edda95a">More...</a><br/></td></tr>
<tr class="separator:a11dc11c40862fe22c0ebab881edda95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1592f546980d76c01e3908fe2a378de"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad1592f546980d76c01e3908fe2a378de"></a>
template&lt;class X &gt; </td></tr>
<tr class="memitem:ad1592f546980d76c01e3908fe2a378de"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian</b> (double(*f)(const X &amp;), const X &amp;x, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:ad1592f546980d76c01e3908fe2a378de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc8958584ec5a638019dc0c9d9975e7"><td class="memTemplParams" colspan="2"><a class="anchor" id="aadc8958584ec5a638019dc0c9d9975e7"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:aadc8958584ec5a638019dc0c9d9975e7"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian212</b> (boost::function&lt; double(const X1 &amp;, const X2 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:aadc8958584ec5a638019dc0c9d9975e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409737480df475024208ff6d2f1f68e4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a409737480df475024208ff6d2f1f68e4"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a409737480df475024208ff6d2f1f68e4"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian212</b> (double(*f)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:a409737480df475024208ff6d2f1f68e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3fd63ff6037e3e8ffae054dcf63666"><td class="memTemplParams" colspan="2"><a class="anchor" id="add3fd63ff6037e3e8ffae054dcf63666"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:add3fd63ff6037e3e8ffae054dcf63666"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian211</b> (boost::function&lt; double(const X1 &amp;, const X2 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:add3fd63ff6037e3e8ffae054dcf63666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc6fe88faa11ab553d828d79ba23aab"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9bc6fe88faa11ab553d828d79ba23aab"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a9bc6fe88faa11ab553d828d79ba23aab"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian211</b> (double(*f)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:a9bc6fe88faa11ab553d828d79ba23aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abf0cfba34349c2d4c12b4d7c03c122"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1abf0cfba34349c2d4c12b4d7c03c122"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a1abf0cfba34349c2d4c12b4d7c03c122"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian222</b> (boost::function&lt; double(const X1 &amp;, const X2 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:a1abf0cfba34349c2d4c12b4d7c03c122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbe72395d442afe872574fd8b9ddb7d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3fbe72395d442afe872574fd8b9ddb7d"></a>
template&lt;class X1 , class X2 &gt; </td></tr>
<tr class="memitem:a3fbe72395d442afe872574fd8b9ddb7d"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian222</b> (double(*f)(const X1 &amp;, const X2 &amp;), const X1 &amp;x1, const X2 &amp;x2, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:a3fbe72395d442afe872574fd8b9ddb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b0105665f1374c98ee7707e3d35d97"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa0b0105665f1374c98ee7707e3d35d97"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:aa0b0105665f1374c98ee7707e3d35d97"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#aa0b0105665f1374c98ee7707e3d35d97">numericalHessian311</a> (boost::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="memdesc:aa0b0105665f1374c98ee7707e3d35d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerical Hessian for tenary functions. <br/></td></tr>
<tr class="separator:aa0b0105665f1374c98ee7707e3d35d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdf9aba21acf8f054bbead3f50198ae"><td class="memTemplParams" colspan="2"><a class="anchor" id="abcdf9aba21acf8f054bbead3f50198ae"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:abcdf9aba21acf8f054bbead3f50198ae"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian311</b> (double(*f)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:abcdf9aba21acf8f054bbead3f50198ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd8c734e71cead717573fd0aaefe3c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6bd8c734e71cead717573fd0aaefe3c4"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a6bd8c734e71cead717573fd0aaefe3c4"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian322</b> (boost::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:a6bd8c734e71cead717573fd0aaefe3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ed93a8becceb3b101286db9c320b42"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae9ed93a8becceb3b101286db9c320b42"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:ae9ed93a8becceb3b101286db9c320b42"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian322</b> (double(*f)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:ae9ed93a8becceb3b101286db9c320b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347346234e1e94248602a7486019c827"><td class="memTemplParams" colspan="2"><a class="anchor" id="a347346234e1e94248602a7486019c827"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a347346234e1e94248602a7486019c827"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian333</b> (boost::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:a347346234e1e94248602a7486019c827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f42cef3df34ae6117340347704ba988"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1f42cef3df34ae6117340347704ba988"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a1f42cef3df34ae6117340347704ba988"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian333</b> (double(*f)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:a1f42cef3df34ae6117340347704ba988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63fbe41ccbcda42c062f63c44833c46"><td class="memTemplParams" colspan="2"><a class="anchor" id="af63fbe41ccbcda42c062f63c44833c46"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:af63fbe41ccbcda42c062f63c44833c46"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian312</b> (boost::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:af63fbe41ccbcda42c062f63c44833c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e62093361a6ae91efb33871c776598"><td class="memTemplParams" colspan="2"><a class="anchor" id="a07e62093361a6ae91efb33871c776598"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a07e62093361a6ae91efb33871c776598"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian313</b> (boost::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:a07e62093361a6ae91efb33871c776598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee14c56bb3c0dee17ffd2b3b4d6862c3"><td class="memTemplParams" colspan="2"><a class="anchor" id="aee14c56bb3c0dee17ffd2b3b4d6862c3"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:aee14c56bb3c0dee17ffd2b3b4d6862c3"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian323</b> (boost::function&lt; double(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt; f, const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:aee14c56bb3c0dee17ffd2b3b4d6862c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce2f7a50b649415b17e9cb0dab15582"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5ce2f7a50b649415b17e9cb0dab15582"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:a5ce2f7a50b649415b17e9cb0dab15582"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian312</b> (double(*f)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:a5ce2f7a50b649415b17e9cb0dab15582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4ffd1a329bc0f1e9e76a047d623924"><td class="memTemplParams" colspan="2"><a class="anchor" id="afe4ffd1a329bc0f1e9e76a047d623924"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:afe4ffd1a329bc0f1e9e76a047d623924"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian313</b> (double(*f)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:afe4ffd1a329bc0f1e9e76a047d623924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac11116d2d3ca642db967f4bd5fa28d"><td class="memTemplParams" colspan="2"><a class="anchor" id="abac11116d2d3ca642db967f4bd5fa28d"></a>
template&lt;class X1 , class X2 , class X3 &gt; </td></tr>
<tr class="memitem:abac11116d2d3ca642db967f4bd5fa28d"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><b>numericalHessian323</b> (double(*f)(const X1 &amp;, const X2 &amp;, const X3 &amp;), const X1 &amp;x1, const X2 &amp;x2, const X3 &amp;x3, double <a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>=1e-5)</td></tr>
<tr class="separator:abac11116d2d3ca642db967f4bd5fa28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332bad7d1e70d3c04ceca35adce7a134"><td class="memTemplParams" colspan="2"><a class="anchor" id="a332bad7d1e70d3c04ceca35adce7a134"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a332bad7d1e70d3c04ceca35adce7a134"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (const T &amp;input)</td></tr>
<tr class="separator:a332bad7d1e70d3c04ceca35adce7a134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d516d0d98946341ad2766521011d1b"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa4d516d0d98946341ad2766521011d1b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa4d516d0d98946341ad2766521011d1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserialize</b> (const std::string &amp;serialized, T &amp;output)</td></tr>
<tr class="separator:aa4d516d0d98946341ad2766521011d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3261c2d455f892dae1921f8c3a39267"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa3261c2d455f892dae1921f8c3a39267"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa3261c2d455f892dae1921f8c3a39267"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serializeToFile</b> (const T &amp;input, const std::string &amp;filename)</td></tr>
<tr class="separator:aa3261c2d455f892dae1921f8c3a39267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb4a71187706918faca3a11519b62f6"><td class="memTemplParams" colspan="2"><a class="anchor" id="adbb4a71187706918faca3a11519b62f6"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:adbb4a71187706918faca3a11519b62f6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializeFromFile</b> (const std::string &amp;filename, T &amp;output)</td></tr>
<tr class="separator:adbb4a71187706918faca3a11519b62f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976ff7999fcc13ef602b6ece1b078bca"><td class="memTemplParams" colspan="2"><a class="anchor" id="a976ff7999fcc13ef602b6ece1b078bca"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a976ff7999fcc13ef602b6ece1b078bca"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serializeXML</b> (const T &amp;input, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="separator:a976ff7999fcc13ef602b6ece1b078bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ab51b2e8f4cea69f72e06a5c136e85"><td class="memTemplParams" colspan="2"><a class="anchor" id="a85ab51b2e8f4cea69f72e06a5c136e85"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a85ab51b2e8f4cea69f72e06a5c136e85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializeXML</b> (const std::string &amp;serialized, T &amp;output, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="separator:a85ab51b2e8f4cea69f72e06a5c136e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89449123a746480a1d668cecb5576708"><td class="memTemplParams" colspan="2"><a class="anchor" id="a89449123a746480a1d668cecb5576708"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a89449123a746480a1d668cecb5576708"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serializeToXMLFile</b> (const T &amp;input, const std::string &amp;filename, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="separator:a89449123a746480a1d668cecb5576708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8faf2bb0a908ff484677bb2fcf707c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0d8faf2bb0a908ff484677bb2fcf707c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0d8faf2bb0a908ff484677bb2fcf707c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializeFromXMLFile</b> (const std::string &amp;filename, T &amp;output, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="separator:a0d8faf2bb0a908ff484677bb2fcf707c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb476c3e77878f7e0f70dd51871f48e7"><td class="memTemplParams" colspan="2"><a class="anchor" id="abb476c3e77878f7e0f70dd51871f48e7"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abb476c3e77878f7e0f70dd51871f48e7"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serializeBinary</b> (const T &amp;input, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="separator:abb476c3e77878f7e0f70dd51871f48e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c41958e57a4bc7361ab593011462fd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a56c41958e57a4bc7361ab593011462fd"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a56c41958e57a4bc7361ab593011462fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializeBinary</b> (const std::string &amp;serialized, T &amp;output, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="separator:a56c41958e57a4bc7361ab593011462fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdff0a4b4fdf0e609aa62fb8d8b1dbba"><td class="memTemplParams" colspan="2"><a class="anchor" id="abdff0a4b4fdf0e609aa62fb8d8b1dbba"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:abdff0a4b4fdf0e609aa62fb8d8b1dbba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serializeToBinaryFile</b> (const T &amp;input, const std::string &amp;filename, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="separator:abdff0a4b4fdf0e609aa62fb8d8b1dbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefeb77f2324e4bbfca2c8152c49a4565"><td class="memTemplParams" colspan="2"><a class="anchor" id="aefeb77f2324e4bbfca2c8152c49a4565"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aefeb77f2324e4bbfca2c8152c49a4565"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deserializeFromBinaryFile</b> (const std::string &amp;filename, T &amp;output, const std::string &amp;name=&quot;data&quot;)</td></tr>
<tr class="separator:aefeb77f2324e4bbfca2c8152c49a4565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f25326667c8e905e3a7065ece2b307"><td class="memTemplParams" colspan="2"><a class="anchor" id="a04f25326667c8e905e3a7065ece2b307"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a04f25326667c8e905e3a7065ece2b307"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a04f25326667c8e905e3a7065ece2b307">print</a> (const T &amp;object, const std::string &amp;s=&quot;&quot;)</td></tr>
<tr class="memdesc:a04f25326667c8e905e3a7065ece2b307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call print on the object. <br/></td></tr>
<tr class="separator:a04f25326667c8e905e3a7065ece2b307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dbee4a72127938c79162cc8b6d5152"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad2dbee4a72127938c79162cc8b6d5152"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad2dbee4a72127938c79162cc8b6d5152"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#ad2dbee4a72127938c79162cc8b6d5152">equal</a> (const T &amp;obj1, const T &amp;obj2, double tol)</td></tr>
<tr class="memdesc:ad2dbee4a72127938c79162cc8b6d5152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call equal on the object. <br/></td></tr>
<tr class="separator:ad2dbee4a72127938c79162cc8b6d5152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3dc67ad88b799c469088e428c583b1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1f3dc67ad88b799c469088e428c583b1"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1f3dc67ad88b799c469088e428c583b1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a1f3dc67ad88b799c469088e428c583b1">equal</a> (const T &amp;obj1, const T &amp;obj2)</td></tr>
<tr class="memdesc:a1f3dc67ad88b799c469088e428c583b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call equal on the object without tolerance (use default tolerance) <br/></td></tr>
<tr class="separator:a1f3dc67ad88b799c469088e428c583b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659619cca082d1c10b07c033d48c54da"><td class="memTemplParams" colspan="2"><a class="anchor" id="a659619cca082d1c10b07c033d48c54da"></a>
template&lt;class V &gt; </td></tr>
<tr class="memitem:a659619cca082d1c10b07c033d48c54da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a659619cca082d1c10b07c033d48c54da">assert_equal</a> (const V &amp;expected, const V &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:a659619cca082d1c10b07c033d48c54da"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template works for any type with equals. <br/></td></tr>
<tr class="separator:a659619cca082d1c10b07c033d48c54da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982034802415eb6e9bd02355257ed96a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a982034802415eb6e9bd02355257ed96a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a982034802415eb6e9bd02355257ed96a">assert_equal</a> (const <a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> &amp;expected, const <a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> &amp;actual, double tol=0.0)</td></tr>
<tr class="memdesc:a982034802415eb6e9bd02355257ed96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equals testing for basic types. <br/></td></tr>
<tr class="separator:a982034802415eb6e9bd02355257ed96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6d6575582314cc9b5dbdbe2a86374d"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:add6d6575582314cc9b5dbdbe2a86374d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#add6d6575582314cc9b5dbdbe2a86374d">assert_equal</a> (const boost::optional&lt; V &gt; &amp;expected, const boost::optional&lt; V &gt; &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:add6d6575582314cc9b5dbdbe2a86374d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparisons for boost.optional objects that checks whether objects exist before comparing their values.  <a href="#add6d6575582314cc9b5dbdbe2a86374d">More...</a><br/></td></tr>
<tr class="separator:add6d6575582314cc9b5dbdbe2a86374d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb156f7b9ac630cc6fd956b386cf1dab"><td class="memTemplParams" colspan="2"><a class="anchor" id="abb156f7b9ac630cc6fd956b386cf1dab"></a>
template&lt;class V &gt; </td></tr>
<tr class="memitem:abb156f7b9ac630cc6fd956b386cf1dab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assert_equal</b> (const V &amp;expected, const boost::optional&lt; V &gt; &amp;actual, double tol=1e-9)</td></tr>
<tr class="separator:abb156f7b9ac630cc6fd956b386cf1dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5242be27f83219abc3f9793975986a35"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5242be27f83219abc3f9793975986a35"></a>
template&lt;class V &gt; </td></tr>
<tr class="memitem:a5242be27f83219abc3f9793975986a35"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assert_equal</b> (const V &amp;expected, const boost::optional&lt; const V &amp; &gt; &amp;actual, double tol=1e-9)</td></tr>
<tr class="separator:a5242be27f83219abc3f9793975986a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0931276a9406dfc1bcff6d265704ee39"><td class="memTemplParams" colspan="2">template&lt;class V &gt; </td></tr>
<tr class="memitem:a0931276a9406dfc1bcff6d265704ee39"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a0931276a9406dfc1bcff6d265704ee39">assert_equal</a> (const std::vector&lt; V &gt; &amp;expected, const std::vector&lt; V &gt; &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:a0931276a9406dfc1bcff6d265704ee39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of assert_equals to work with vectors.  <a href="#a0931276a9406dfc1bcff6d265704ee39">More...</a><br/></td></tr>
<tr class="separator:a0931276a9406dfc1bcff6d265704ee39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254be27d6d4b416fa2b546c77ae783fc"><td class="memTemplParams" colspan="2"><a class="anchor" id="a254be27d6d4b416fa2b546c77ae783fc"></a>
template&lt;class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a254be27d6d4b416fa2b546c77ae783fc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a254be27d6d4b416fa2b546c77ae783fc">assert_container_equal</a> (const std::map&lt; V1, V2 &gt; &amp;expected, const std::map&lt; V1, V2 &gt; &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:a254be27d6d4b416fa2b546c77ae783fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for comparing maps of testable-&gt;testable TODO: replace with more generalized version. <br/></td></tr>
<tr class="separator:a254be27d6d4b416fa2b546c77ae783fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f509195ea2180d0f7dbd3a99a088ff4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2f509195ea2180d0f7dbd3a99a088ff4"></a>
template&lt;class V2 &gt; </td></tr>
<tr class="memitem:a2f509195ea2180d0f7dbd3a99a088ff4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a2f509195ea2180d0f7dbd3a99a088ff4">assert_container_equal</a> (const std::map&lt; size_t, V2 &gt; &amp;expected, const std::map&lt; size_t, V2 &gt; &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:a2f509195ea2180d0f7dbd3a99a088ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for comparing maps of size_t-&gt;testable. <br/></td></tr>
<tr class="separator:a2f509195ea2180d0f7dbd3a99a088ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eec17f894b358dd9f30d7af28082ba5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0eec17f894b358dd9f30d7af28082ba5"></a>
template&lt;class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a0eec17f894b358dd9f30d7af28082ba5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a0eec17f894b358dd9f30d7af28082ba5">assert_container_equal</a> (const std::vector&lt; std::pair&lt; V1, V2 &gt; &gt; &amp;expected, const std::vector&lt; std::pair&lt; V1, V2 &gt; &gt; &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:a0eec17f894b358dd9f30d7af28082ba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for comparing vector of pairs (testable, testable) <br/></td></tr>
<tr class="separator:a0eec17f894b358dd9f30d7af28082ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6b2964354593f69848f6bf5d3e0ca1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6d6b2964354593f69848f6bf5d3e0ca1"></a>
template&lt;class V &gt; </td></tr>
<tr class="memitem:a6d6b2964354593f69848f6bf5d3e0ca1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a6d6b2964354593f69848f6bf5d3e0ca1">assert_container_equal</a> (const V &amp;expected, const V &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:a6d6b2964354593f69848f6bf5d3e0ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">General function for comparing containers of testable objects. <br/></td></tr>
<tr class="separator:a6d6b2964354593f69848f6bf5d3e0ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ba6a7db27344c5cb021f1421905020"><td class="memTemplParams" colspan="2"><a class="anchor" id="a59ba6a7db27344c5cb021f1421905020"></a>
template&lt;class V2 &gt; </td></tr>
<tr class="memitem:a59ba6a7db27344c5cb021f1421905020"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a59ba6a7db27344c5cb021f1421905020">assert_container_equality</a> (const std::map&lt; size_t, V2 &gt; &amp;expected, const std::map&lt; size_t, V2 &gt; &amp;actual)</td></tr>
<tr class="memdesc:a59ba6a7db27344c5cb021f1421905020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for comparing maps of size_t-&gt;testable Types are assumed to have operator ==. <br/></td></tr>
<tr class="separator:a59ba6a7db27344c5cb021f1421905020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0926a5d779171bd8e1d30fb5982b5c0"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa0926a5d779171bd8e1d30fb5982b5c0"></a>
template&lt;class V &gt; </td></tr>
<tr class="memitem:aa0926a5d779171bd8e1d30fb5982b5c0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#aa0926a5d779171bd8e1d30fb5982b5c0">assert_container_equality</a> (const V &amp;expected, const V &amp;actual)</td></tr>
<tr class="memdesc:aa0926a5d779171bd8e1d30fb5982b5c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">General function for comparing containers of objects with operator==. <br/></td></tr>
<tr class="separator:aa0926a5d779171bd8e1d30fb5982b5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e760bc75888053afd86a27d56b6148"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21e760bc75888053afd86a27d56b6148"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a21e760bc75888053afd86a27d56b6148">assert_equal</a> (const std::string &amp;expected, const std::string &amp;actual)</td></tr>
<tr class="memdesc:a21e760bc75888053afd86a27d56b6148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare strings for unit tests. <br/></td></tr>
<tr class="separator:a21e760bc75888053afd86a27d56b6148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f19ba6625a264457805513fefcb5c32"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2f19ba6625a264457805513fefcb5c32"></a>
template&lt;class V &gt; </td></tr>
<tr class="memitem:a2f19ba6625a264457805513fefcb5c32"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a2f19ba6625a264457805513fefcb5c32">assert_inequal</a> (const V &amp;expected, const V &amp;actual, double tol=1e-9)</td></tr>
<tr class="memdesc:a2f19ba6625a264457805513fefcb5c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow for testing inequality. <br/></td></tr>
<tr class="separator:a2f19ba6625a264457805513fefcb5c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3230ae4ee4a803cf8d837ea66a735703"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3230ae4ee4a803cf8d837ea66a735703"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tictoc_finishedIteration_</b> ()</td></tr>
<tr class="separator:a3230ae4ee4a803cf8d837ea66a735703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4733cdc946435aef61a5478b201d1042"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4733cdc946435aef61a5478b201d1042"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tictoc_print_</b> ()</td></tr>
<tr class="separator:a4733cdc946435aef61a5478b201d1042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7945a7256f5f54c8fcf0c2aa1bf4b3f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7945a7256f5f54c8fcf0c2aa1bf4b3f9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tictoc_print2_</b> ()</td></tr>
<tr class="separator:a7945a7256f5f54c8fcf0c2aa1bf4b3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e469989c2312c6c5ccb33b1202ef41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05e469989c2312c6c5ccb33b1202ef41"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>tictoc_reset_</b> ()</td></tr>
<tr class="separator:a05e469989c2312c6c5ccb33b1202ef41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6435f73056db87524ffa53c2f7e8c72a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6435f73056db87524ffa53c2f7e8c72a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>_defaultKeyFormatter</b> (<a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> key)</td></tr>
<tr class="separator:a6435f73056db87524ffa53c2f7e8c72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac272566642a6375b8981b8620f6d7cc5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac272566642a6375b8981b8620f6d7cc5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>BOOST_CONCEPT_ASSERT</b> ((boost::RandomAccessRangeConcept&lt; <a class="el" href="a00154.html">ListOfOneContainer</a>&lt; int &gt; &gt;))</td></tr>
<tr class="separator:ac272566642a6375b8981b8620f6d7cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ed0dcde6a0084d7f1792c396e5dbaf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac3ed0dcde6a0084d7f1792c396e5dbaf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00154.html">ListOfOneContainer</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#ac3ed0dcde6a0084d7f1792c396e5dbaf">ListOfOne</a> (const T &amp;element)</td></tr>
<tr class="memdesc:ac3ed0dcde6a0084d7f1792c396e5dbaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory function for <a class="el" href="a00154.html" title="A helper class that behaves as a container with one element, and works with boost::range.">ListOfOneContainer</a> to enable ListOfOne(e) syntax.  <a href="#ac3ed0dcde6a0084d7f1792c396e5dbaf">More...</a><br/></td></tr>
<tr class="separator:ac3ed0dcde6a0084d7f1792c396e5dbaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8725ddddd5e780177cf69df55df2f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc8725ddddd5e780177cf69df55df2f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>odprintf_</b> (const char *format, ostream &amp;stream,...)</td></tr>
<tr class="separator:adc8725ddddd5e780177cf69df55df2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9a97513901635b46a3149bea00fad7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f9a97513901635b46a3149bea00fad7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a5f9a97513901635b46a3149bea00fad7">odprintf</a> (const char *format,...)</td></tr>
<tr class="memdesc:a5f9a97513901635b46a3149bea00fad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">An auxiliary function to printf for Win32 compatibility, added by Kai. <br/></td></tr>
<tr class="separator:a5f9a97513901635b46a3149bea00fad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33561b8886a11b2de66f9dab4c7380e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33561b8886a11b2de66f9dab4c7380e3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a33561b8886a11b2de66f9dab4c7380e3">zero</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:a33561b8886a11b2de66f9dab4c7380e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if all zero <br/></td></tr>
<tr class="separator:a33561b8886a11b2de66f9dab4c7380e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50343afb840c2e690b5b86b69ab691a"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#af50343afb840c2e690b5b86b69ab691a">repeat</a> (size_t n, double value)</td></tr>
<tr class="memdesc:af50343afb840c2e690b5b86b69ab691a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create vector initialized to a constant value.  <a href="#af50343afb840c2e690b5b86b69ab691a">More...</a><br/></td></tr>
<tr class="separator:af50343afb840c2e690b5b86b69ab691a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a0ba4a7a13e0f4c781fa9de3e5689e"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a> (size_t n, size_t i, double value)</td></tr>
<tr class="memdesc:ac2a0ba4a7a13e0f4c781fa9de3e5689e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create basis vector of dimension n, with a constant in spot i.  <a href="#ac2a0ba4a7a13e0f4c781fa9de3e5689e">More...</a><br/></td></tr>
<tr class="separator:ac2a0ba4a7a13e0f4c781fa9de3e5689e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad264e350453db2df8b12f66c670ad0e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad264e350453db2df8b12f66c670ad0e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ad264e350453db2df8b12f66c670ad0e7">print</a> (const Vector &amp;v, const std::string &amp;s=&quot;&quot;, std::ostream &amp;stream=std::cout)</td></tr>
<tr class="memdesc:ad264e350453db2df8b12f66c670ad0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">print with optional string <br/></td></tr>
<tr class="separator:ad264e350453db2df8b12f66c670ad0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f2bbdb9f9d633542362dbe8d79f9ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09f2bbdb9f9d633542362dbe8d79f9ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a09f2bbdb9f9d633542362dbe8d79f9ab">save</a> (const Vector &amp;A, const std::string &amp;s, const std::string &amp;filename)</td></tr>
<tr class="memdesc:a09f2bbdb9f9d633542362dbe8d79f9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">save a vector to file, which can be loaded by matlab <br/></td></tr>
<tr class="separator:a09f2bbdb9f9d633542362dbe8d79f9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64988014ab746343803620dc42513646"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64988014ab746343803620dc42513646"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a64988014ab746343803620dc42513646">operator==</a> (const Vector &amp;vec1, const Vector &amp;vec2)</td></tr>
<tr class="memdesc:a64988014ab746343803620dc42513646"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="a00290.html#afd5b3cf3f54adcbdd6d9e7403f1a792f" title="equality is just equal_with_abs_tol 1e-9">operator==()</a> <br/></td></tr>
<tr class="separator:a64988014ab746343803620dc42513646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368ee40bd9c0124d572d2e49bcb077bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a368ee40bd9c0124d572d2e49bcb077bf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a368ee40bd9c0124d572d2e49bcb077bf">greaterThanOrEqual</a> (const Vector &amp;v1, const Vector &amp;v2)</td></tr>
<tr class="memdesc:a368ee40bd9c0124d572d2e49bcb077bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal to operation returns true if all elements in v1 are greater than corresponding elements in v2. <br/></td></tr>
<tr class="separator:a368ee40bd9c0124d572d2e49bcb077bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdced1844ffd6a53af0396d82eaa6da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bdced1844ffd6a53af0396d82eaa6da"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a8bdced1844ffd6a53af0396d82eaa6da">equal_with_abs_tol</a> (const Vector &amp;vec1, const Vector &amp;vec2, double tol=1e-9)</td></tr>
<tr class="memdesc:a8bdced1844ffd6a53af0396d82eaa6da"><td class="mdescLeft">&#160;</td><td class="mdescRight">VecA == VecB up to tolerance. <br/></td></tr>
<tr class="separator:a8bdced1844ffd6a53af0396d82eaa6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14034da7e28c95db712ec344d4a2ffaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14034da7e28c95db712ec344d4a2ffaf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>equal_with_abs_tol</b> (const SubVector &amp;vec1, const SubVector &amp;vec2, double tol)</td></tr>
<tr class="separator:a14034da7e28c95db712ec344d4a2ffaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3ee662d25ffb8c04b4e35c4b02e90b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a9f3ee662d25ffb8c04b4e35c4b02e90b">assert_equal</a> (const Vector &amp;vec1, const Vector &amp;vec2, double tol=1e-9)</td></tr>
<tr class="memdesc:a9f3ee662d25ffb8c04b4e35c4b02e90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same, prints if error.  <a href="#a9f3ee662d25ffb8c04b4e35c4b02e90b">More...</a><br/></td></tr>
<tr class="separator:a9f3ee662d25ffb8c04b4e35c4b02e90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca3db47b15350977c1f03c5560ab332"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a2ca3db47b15350977c1f03c5560ab332">assert_inequal</a> (const Vector &amp;vec1, const Vector &amp;vec2, double tol=1e-9)</td></tr>
<tr class="memdesc:a2ca3db47b15350977c1f03c5560ab332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not the same, prints if error.  <a href="#a2ca3db47b15350977c1f03c5560ab332">More...</a><br/></td></tr>
<tr class="separator:a2ca3db47b15350977c1f03c5560ab332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cf8e8e70cd696d9c789c31bc1e89a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ac3cf8e8e70cd696d9c789c31bc1e89a7">assert_equal</a> (const SubVector &amp;vec1, const SubVector &amp;vec2, double tol=1e-9)</td></tr>
<tr class="memdesc:ac3cf8e8e70cd696d9c789c31bc1e89a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same, prints if error.  <a href="#ac3cf8e8e70cd696d9c789c31bc1e89a7">More...</a><br/></td></tr>
<tr class="separator:ac3cf8e8e70cd696d9c789c31bc1e89a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95292df1087c65aa5b5388bf4c11842"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac95292df1087c65aa5b5388bf4c11842"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>assert_equal</b> (const ConstSubVector &amp;expected, const ConstSubVector &amp;actual, double tol)</td></tr>
<tr class="separator:ac95292df1087c65aa5b5388bf4c11842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0cfd7908b06491df49b6a9c9186775"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a2a0cfd7908b06491df49b6a9c9186775">linear_dependent</a> (const Vector &amp;vec1, const Vector &amp;vec2, double tol=1e-9)</td></tr>
<tr class="memdesc:a2a0cfd7908b06491df49b6a9c9186775"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether two vectors are linearly dependent  <a href="#a2a0cfd7908b06491df49b6a9c9186775">More...</a><br/></td></tr>
<tr class="separator:a2a0cfd7908b06491df49b6a9c9186775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af694dd7a0838c24e3484068cc1657f4a"><td class="memItemLeft" align="right" valign="top">ConstSubVector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#af694dd7a0838c24e3484068cc1657f4a">sub</a> (const Vector &amp;v, size_t i1, size_t i2)</td></tr>
<tr class="memdesc:af694dd7a0838c24e3484068cc1657f4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract subvector, slice semantics, i.e.  <a href="#af694dd7a0838c24e3484068cc1657f4a">More...</a><br/></td></tr>
<tr class="separator:af694dd7a0838c24e3484068cc1657f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe442f79470225ffccfc8bc5ce46a87a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#abe442f79470225ffccfc8bc5ce46a87a">subInsert</a> (Vector &amp;fullVector, const Vector &amp;subVector, size_t i)</td></tr>
<tr class="memdesc:abe442f79470225ffccfc8bc5ce46a87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a subvector into a vector IN PLACE.  <a href="#abe442f79470225ffccfc8bc5ce46a87a">More...</a><br/></td></tr>
<tr class="separator:abe442f79470225ffccfc8bc5ce46a87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08665ce2fa3fdc3f7ff6d87b26452cc"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ab08665ce2fa3fdc3f7ff6d87b26452cc">emul</a> (const Vector &amp;a, const Vector &amp;b)</td></tr>
<tr class="memdesc:ab08665ce2fa3fdc3f7ff6d87b26452cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise multiplication  <a href="#ab08665ce2fa3fdc3f7ff6d87b26452cc">More...</a><br/></td></tr>
<tr class="separator:ab08665ce2fa3fdc3f7ff6d87b26452cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d4fbafe5819f4617da45c107b3e616"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ac0d4fbafe5819f4617da45c107b3e616">ediv</a> (const Vector &amp;a, const Vector &amp;b)</td></tr>
<tr class="memdesc:ac0d4fbafe5819f4617da45c107b3e616"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise division  <a href="#ac0d4fbafe5819f4617da45c107b3e616">More...</a><br/></td></tr>
<tr class="separator:ac0d4fbafe5819f4617da45c107b3e616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14844c96706dc362917e0d5e76d65fbe"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a14844c96706dc362917e0d5e76d65fbe">ediv_</a> (const Vector &amp;a, const Vector &amp;b)</td></tr>
<tr class="memdesc:a14844c96706dc362917e0d5e76d65fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">elementwise division, but 0/0 = 0, not inf  <a href="#a14844c96706dc362917e0d5e76d65fbe">More...</a><br/></td></tr>
<tr class="separator:a14844c96706dc362917e0d5e76d65fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316a9f631367da3caae876b41b345867"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a316a9f631367da3caae876b41b345867">sum</a> (const Vector &amp;a)</td></tr>
<tr class="memdesc:a316a9f631367da3caae876b41b345867"><td class="mdescLeft">&#160;</td><td class="mdescRight">sum vector elements  <a href="#a316a9f631367da3caae876b41b345867">More...</a><br/></td></tr>
<tr class="separator:a316a9f631367da3caae876b41b345867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3ddc32a5a6b8eed2d5efe69d1cb171"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#aaa3ddc32a5a6b8eed2d5efe69d1cb171">norm_2</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:aaa3ddc32a5a6b8eed2d5efe69d1cb171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates L2 norm for a vector modeled after boost.ublas for compatibility.  <a href="#aaa3ddc32a5a6b8eed2d5efe69d1cb171">More...</a><br/></td></tr>
<tr class="separator:aaa3ddc32a5a6b8eed2d5efe69d1cb171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0853fc18973e23bb407825df52c95515"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a0853fc18973e23bb407825df52c95515">reciprocal</a> (const Vector &amp;a)</td></tr>
<tr class="memdesc:a0853fc18973e23bb407825df52c95515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise reciprocal of vector elements.  <a href="#a0853fc18973e23bb407825df52c95515">More...</a><br/></td></tr>
<tr class="separator:a0853fc18973e23bb407825df52c95515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c974066d393d86d744e9d387f0d3f50"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a6c974066d393d86d744e9d387f0d3f50">esqrt</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:a6c974066d393d86d744e9d387f0d3f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise sqrt of vector elements.  <a href="#a6c974066d393d86d744e9d387f0d3f50">More...</a><br/></td></tr>
<tr class="separator:a6c974066d393d86d744e9d387f0d3f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba06101b45d9f2647608cbf4e3b35aa"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a5ba06101b45d9f2647608cbf4e3b35aa">abs</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:a5ba06101b45d9f2647608cbf4e3b35aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute values of vector elements.  <a href="#a5ba06101b45d9f2647608cbf4e3b35aa">More...</a><br/></td></tr>
<tr class="separator:a5ba06101b45d9f2647608cbf4e3b35aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21cbc51fd8128a843739dbe5e0b2421"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ab21cbc51fd8128a843739dbe5e0b2421">max</a> (const Vector &amp;a)</td></tr>
<tr class="memdesc:ab21cbc51fd8128a843739dbe5e0b2421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the max element of a vector.  <a href="#ab21cbc51fd8128a843739dbe5e0b2421">More...</a><br/></td></tr>
<tr class="separator:ab21cbc51fd8128a843739dbe5e0b2421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c0c05b0198ec0fb6e4115edb755910"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9c0c05b0198ec0fb6e4115edb755910"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ac9c0c05b0198ec0fb6e4115edb755910">houseInPlace</a> (Vector &amp;x)</td></tr>
<tr class="memdesc:ac9c0c05b0198ec0fb6e4115edb755910"><td class="mdescLeft">&#160;</td><td class="mdescRight">beta = house(x) computes the HouseHolder vector in place <br/></td></tr>
<tr class="separator:ac9c0c05b0198ec0fb6e4115edb755910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb77eefc25dea0fb3e0fcc8f246b617a"><td class="memItemLeft" align="right" valign="top">pair&lt; double, Vector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#afb77eefc25dea0fb3e0fcc8f246b617a">house</a> (const Vector &amp;x)</td></tr>
<tr class="memdesc:afb77eefc25dea0fb3e0fcc8f246b617a"><td class="mdescLeft">&#160;</td><td class="mdescRight">house(x,j) computes HouseHolder vector v and scaling factor beta from x, such that the corresponding Householder reflection zeroes out all but x.  <a href="#afb77eefc25dea0fb3e0fcc8f246b617a">More...</a><br/></td></tr>
<tr class="separator:afb77eefc25dea0fb3e0fcc8f246b617a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3f9d6140621a7e935f051d8fb23284"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca3f9d6140621a7e935f051d8fb23284"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>weightedPseudoinverse</b> (const Vector &amp;a, const Vector &amp;weights, Vector &amp;pseudo)</td></tr>
<tr class="separator:aca3f9d6140621a7e935f051d8fb23284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1c56d11a05464a7a5458dc32ccc777"><td class="memItemLeft" align="right" valign="top">pair&lt; Vector, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#aca1c56d11a05464a7a5458dc32ccc777">weightedPseudoinverse</a> (const Vector &amp;v, const Vector &amp;weights)</td></tr>
<tr class="memdesc:aca1c56d11a05464a7a5458dc32ccc777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weighted Householder solution vector, a.k.a., the pseudoinverse of the column NOTE: if any sigmas are zero (indicating a constraint) the pseudoinverse will be a selection vector, and the variance will be zero.  <a href="#aca1c56d11a05464a7a5458dc32ccc777">More...</a><br/></td></tr>
<tr class="separator:aca1c56d11a05464a7a5458dc32ccc777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c88acfa9575bcea3f2e738cb637a85"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1c88acfa9575bcea3f2e738cb637a85"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ae1c88acfa9575bcea3f2e738cb637a85">concatVectors</a> (const std::list&lt; Vector &gt; &amp;vs)</td></tr>
<tr class="memdesc:ae1c88acfa9575bcea3f2e738cb637a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">concatenate Vectors <br/></td></tr>
<tr class="separator:ae1c88acfa9575bcea3f2e738cb637a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09610ec69a8b3f3a00399bb378eda9cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09610ec69a8b3f3a00399bb378eda9cf"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a09610ec69a8b3f3a00399bb378eda9cf">concatVectors</a> (size_t nrVectors,...)</td></tr>
<tr class="memdesc:a09610ec69a8b3f3a00399bb378eda9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">concatenate Vectors <br/></td></tr>
<tr class="separator:a09610ec69a8b3f3a00399bb378eda9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec32e8dafe1d25ab11de3d693c1b5a4"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a6ec32e8dafe1d25ab11de3d693c1b5a4">basis</a> (size_t n, size_t i)</td></tr>
<tr class="memdesc:a6ec32e8dafe1d25ab11de3d693c1b5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create basis vector of dimension n, with one in spot i.  <a href="#a6ec32e8dafe1d25ab11de3d693c1b5a4">More...</a><br/></td></tr>
<tr class="separator:a6ec32e8dafe1d25ab11de3d693c1b5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067f9515f6cd64987f4604127398fb9d"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a067f9515f6cd64987f4604127398fb9d">zero</a> (size_t n)</td></tr>
<tr class="memdesc:a067f9515f6cd64987f4604127398fb9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create zero vector.  <a href="#a067f9515f6cd64987f4604127398fb9d">More...</a><br/></td></tr>
<tr class="separator:a067f9515f6cd64987f4604127398fb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4782bb65cdbe1fdd391080d1754a20f"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#aa4782bb65cdbe1fdd391080d1754a20f">ones</a> (size_t n)</td></tr>
<tr class="memdesc:aa4782bb65cdbe1fdd391080d1754a20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create vector initialized to ones.  <a href="#aa4782bb65cdbe1fdd391080d1754a20f">More...</a><br/></td></tr>
<tr class="separator:aa4782bb65cdbe1fdd391080d1754a20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3740ee8f898205aa46c6b3f78fbb817a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3740ee8f898205aa46c6b3f78fbb817a"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a3740ee8f898205aa46c6b3f78fbb817a">dim</a> (const Vector &amp;v)</td></tr>
<tr class="memdesc:a3740ee8f898205aa46c6b3f78fbb817a"><td class="mdescLeft">&#160;</td><td class="mdescRight">dimensionality == size <br/></td></tr>
<tr class="separator:a3740ee8f898205aa46c6b3f78fbb817a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ed1d4fe2dd6828cfeb2d8f488b818d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7ed1d4fe2dd6828cfeb2d8f488b818d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#aa7ed1d4fe2dd6828cfeb2d8f488b818d">equal</a> (const Vector &amp;vec1, const Vector &amp;vec2, double tol)</td></tr>
<tr class="memdesc:aa7ed1d4fe2dd6828cfeb2d8f488b818d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of equal in <a class="el" href="a00271.html" title="Base class and basic functions for Lie types.">Lie.h</a>. <br/></td></tr>
<tr class="separator:aa7ed1d4fe2dd6828cfeb2d8f488b818d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1cad2313f69f9fa5008fdc348d1526"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d1cad2313f69f9fa5008fdc348d1526"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a3d1cad2313f69f9fa5008fdc348d1526">equal</a> (const Vector &amp;vec1, const Vector &amp;vec2)</td></tr>
<tr class="memdesc:a3d1cad2313f69f9fa5008fdc348d1526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of equal in <a class="el" href="a00271.html" title="Base class and basic functions for Lie types.">Lie.h</a>. <br/></td></tr>
<tr class="separator:a3d1cad2313f69f9fa5008fdc348d1526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80249acf12bbea741e755cd8fc73042"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad80249acf12bbea741e755cd8fc73042"></a>
template&lt;class V1 , class V2 &gt; </td></tr>
<tr class="memitem:ad80249acf12bbea741e755cd8fc73042"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#ad80249acf12bbea741e755cd8fc73042">dot</a> (const V1 &amp;a, const V2 &amp;b)</td></tr>
<tr class="memdesc:ad80249acf12bbea741e755cd8fc73042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product. <br/></td></tr>
<tr class="separator:ad80249acf12bbea741e755cd8fc73042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca41ba9ec9d6d21a2b9f5e00f9f25ed"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4ca41ba9ec9d6d21a2b9f5e00f9f25ed"></a>
template&lt;class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a4ca41ba9ec9d6d21a2b9f5e00f9f25ed"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a4ca41ba9ec9d6d21a2b9f5e00f9f25ed">inner_prod</a> (const V1 &amp;a, const V2 &amp;b)</td></tr>
<tr class="memdesc:a4ca41ba9ec9d6d21a2b9f5e00f9f25ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">compatibility version for ublas' <a class="el" href="a00290.html#a4ca41ba9ec9d6d21a2b9f5e00f9f25ed" title="compatibility version for ublas&#39; inner_prod()">inner_prod()</a> <br/></td></tr>
<tr class="separator:a4ca41ba9ec9d6d21a2b9f5e00f9f25ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad371582718b5e685ace31c176f2a9abc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ad371582718b5e685ace31c176f2a9abc">scal</a> (double alpha, Vector &amp;x)</td></tr>
<tr class="memdesc:ad371582718b5e685ace31c176f2a9abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS Level 1 scal: x &lt;- alpha*x.  <a href="#ad371582718b5e685ace31c176f2a9abc">More...</a><br/></td></tr>
<tr class="separator:ad371582718b5e685ace31c176f2a9abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a89a0147943428129e2cb3683988be"><td class="memTemplParams" colspan="2">template&lt;class V1 , class V2 &gt; </td></tr>
<tr class="memitem:a30a89a0147943428129e2cb3683988be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a30a89a0147943428129e2cb3683988be">axpy</a> (double alpha, const V1 &amp;x, V2 &amp;y)</td></tr>
<tr class="memdesc:a30a89a0147943428129e2cb3683988be"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS Level 1 axpy: y &lt;- alpha*x + y.  <a href="#a30a89a0147943428129e2cb3683988be">More...</a><br/></td></tr>
<tr class="separator:a30a89a0147943428129e2cb3683988be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6947eb9313cdaf0a67bbc333e57e387f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6947eb9313cdaf0a67bbc333e57e387f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>axpy</b> (double alpha, const Vector &amp;x, SubVector y)</td></tr>
<tr class="separator:a6947eb9313cdaf0a67bbc333e57e387f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20225b40131a9d882a7ac5f9b87574b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20225b40131a9d882a7ac5f9b87574b0"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a00076.html">EssentialMatrix</a> &amp;E)</td></tr>
<tr class="separator:a20225b40131a9d882a7ac5f9b87574b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a122b19448180a732e4cd64ee8bc62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08a122b19448180a732e4cd64ee8bc62"></a>
istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;&gt;</b> (istream &amp;is, <a class="el" href="a00076.html">EssentialMatrix</a> &amp;E)</td></tr>
<tr class="separator:a08a122b19448180a732e4cd64ee8bc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab498ebc225b8ecec9c0176a7460b9da5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab498ebc225b8ecec9c0176a7460b9da5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ab498ebc225b8ecec9c0176a7460b9da5">INSTANTIATE_LIE</a> (<a class="el" href="a00186.html">Point2</a>)</td></tr>
<tr class="memdesc:ab498ebc225b8ecec9c0176a7460b9da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit instantiation of base class to export members. <br/></td></tr>
<tr class="separator:ab498ebc225b8ecec9c0176a7460b9da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaca17bb555bb1993e5e821aee707bd75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaca17bb555bb1993e5e821aee707bd75"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a00186.html">Point2</a> &amp;p)</td></tr>
<tr class="separator:aaca17bb555bb1993e5e821aee707bd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d86e99c211c6daeac2b7b4dd9d928e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63d86e99c211c6daeac2b7b4dd9d928e"></a>
<a class="el" href="a00186.html">Point2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a63d86e99c211c6daeac2b7b4dd9d928e">operator*</a> (double s, const <a class="el" href="a00186.html">Point2</a> &amp;p)</td></tr>
<tr class="memdesc:a63d86e99c211c6daeac2b7b4dd9d928e"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiply with scalar <br/></td></tr>
<tr class="separator:a63d86e99c211c6daeac2b7b4dd9d928e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0574540374ca7142a55b370d4237a1ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0574540374ca7142a55b370d4237a1ec"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a0574540374ca7142a55b370d4237a1ec">INSTANTIATE_LIE</a> (<a class="el" href="a00187.html">Point3</a>)</td></tr>
<tr class="memdesc:a0574540374ca7142a55b370d4237a1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit instantiation of base class to export members. <br/></td></tr>
<tr class="separator:a0574540374ca7142a55b370d4237a1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70fc23d4149c33874a82a4de29b13f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac70fc23d4149c33874a82a4de29b13f4"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a00187.html">Point3</a> &amp;p)</td></tr>
<tr class="separator:ac70fc23d4149c33874a82a4de29b13f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27247b810d31840d7d3fefc2b73c99af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27247b810d31840d7d3fefc2b73c99af"></a>
<a class="el" href="a00187.html">Point3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a27247b810d31840d7d3fefc2b73c99af">operator*</a> (double s, const <a class="el" href="a00187.html">Point3</a> &amp;p)</td></tr>
<tr class="memdesc:a27247b810d31840d7d3fefc2b73c99af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Syntactic sugar for multiplying coordinates by a scalar s*p. <br/></td></tr>
<tr class="separator:a27247b810d31840d7d3fefc2b73c99af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b449384ab2bdade1dc9fdb857011606"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b449384ab2bdade1dc9fdb857011606"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a9b449384ab2bdade1dc9fdb857011606">INSTANTIATE_LIE</a> (<a class="el" href="a00188.html">Pose2</a>)</td></tr>
<tr class="memdesc:a9b449384ab2bdade1dc9fdb857011606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit instantiation of base class to export members. <br/></td></tr>
<tr class="separator:a9b449384ab2bdade1dc9fdb857011606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6efe09721c5221b12b7a3437f0a2bee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6efe09721c5221b12b7a3437f0a2bee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ad6efe09721c5221b12b7a3437f0a2bee">GTSAM_CONCEPT_POSE_INST</a> (<a class="el" href="a00188.html">Pose2</a>)</td></tr>
<tr class="memdesc:ad6efe09721c5221b12b7a3437f0a2bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">instantiate concept checks <br/></td></tr>
<tr class="separator:ad6efe09721c5221b12b7a3437f0a2bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5f3d592b1eb52ab4bf4d34003178f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d5f3d592b1eb52ab4bf4d34003178f0"></a>
boost::optional&lt; <a class="el" href="a00188.html">Pose2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>align</b> (const vector&lt; <a class="el" href="a00290.html#af15dec8cc8bf0a43bc649709b84cf771">Point2Pair</a> &gt; &amp;pairs)</td></tr>
<tr class="separator:a2d5f3d592b1eb52ab4bf4d34003178f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b78f4db0e05f3ca838ee4da6187710e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4b78f4db0e05f3ca838ee4da6187710e"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a4b78f4db0e05f3ca838ee4da6187710e"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a4b78f4db0e05f3ca838ee4da6187710e">wedge&lt; Pose2 &gt;</a> (const Vector &amp;xi)</td></tr>
<tr class="memdesc:a4b78f4db0e05f3ca838ee4da6187710e"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization for pose2 wedge function (generic template in <a class="el" href="a00271.html" title="Base class and basic functions for Lie types.">Lie.h</a>) <br/></td></tr>
<tr class="separator:a4b78f4db0e05f3ca838ee4da6187710e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbeda702e320c082a99bb717a69b017c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbeda702e320c082a99bb717a69b017c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#acbeda702e320c082a99bb717a69b017c">INSTANTIATE_LIE</a> (<a class="el" href="a00189.html">Pose3</a>)</td></tr>
<tr class="memdesc:acbeda702e320c082a99bb717a69b017c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit instantiation of base class to export members. <br/></td></tr>
<tr class="separator:acbeda702e320c082a99bb717a69b017c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a8e9793b8e0d234fb0c83b17a2f5bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10a8e9793b8e0d234fb0c83b17a2f5bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a10a8e9793b8e0d234fb0c83b17a2f5bc">GTSAM_CONCEPT_POSE_INST</a> (<a class="el" href="a00189.html">Pose3</a>)</td></tr>
<tr class="memdesc:a10a8e9793b8e0d234fb0c83b17a2f5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">instantiate concept checks <br/></td></tr>
<tr class="separator:a10a8e9793b8e0d234fb0c83b17a2f5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016eba8839e800a867207d7126551217"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a016eba8839e800a867207d7126551217"></a>
boost::optional&lt; <a class="el" href="a00189.html">Pose3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>align</b> (const vector&lt; <a class="el" href="a00290.html#ac387ee14e9f8e8dc341a6f58330241eb">Point3Pair</a> &gt; &amp;pairs)</td></tr>
<tr class="separator:a016eba8839e800a867207d7126551217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c070c867687a63dc5da15b6f1d12004"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c070c867687a63dc5da15b6f1d12004"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="a00189.html">Pose3</a> &amp;pose)</td></tr>
<tr class="separator:a7c070c867687a63dc5da15b6f1d12004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb606eb24889c0f418acf1515a2c723"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aefb606eb24889c0f418acf1515a2c723"><td class="memTemplItemLeft" align="right" valign="top">Matrix&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#aefb606eb24889c0f418acf1515a2c723">wedge&lt; Pose3 &gt;</a> (const Vector &amp;xi)</td></tr>
<tr class="memdesc:aefb606eb24889c0f418acf1515a2c723"><td class="mdescLeft">&#160;</td><td class="mdescRight">wedge for <a class="el" href="a00189.html">Pose3</a>:  <a href="#aefb606eb24889c0f418acf1515a2c723">More...</a><br/></td></tr>
<tr class="separator:aefb606eb24889c0f418acf1515a2c723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53676b6c16dc20cf5f31f13251230c2f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53676b6c16dc20cf5f31f13251230c2f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a53676b6c16dc20cf5f31f13251230c2f">INSTANTIATE_LIE</a> (<a class="el" href="a00204.html">Rot2</a>)</td></tr>
<tr class="memdesc:a53676b6c16dc20cf5f31f13251230c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit instantiation of base class to export members. <br/></td></tr>
<tr class="separator:a53676b6c16dc20cf5f31f13251230c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e7b1c395b14af00409d9ca3ee4a687"><td class="memItemLeft" align="right" valign="top">pair&lt; Matrix3, Vector3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a59e7b1c395b14af00409d9ca3ee4a687">RQ</a> (const Matrix3 &amp;A)</td></tr>
<tr class="memdesc:a59e7b1c395b14af00409d9ca3ee4a687"><td class="mdescLeft">&#160;</td><td class="mdescRight">[RQ] receives a 3 by 3 matrix and returns an upper triangular matrix R and 3 rotation angles corresponding to the rotation matrix Q=Qz'*Qy'*Qx' such that A = R*Q = R*Qz'*Qy'*Qx'.  <a href="#a59e7b1c395b14af00409d9ca3ee4a687">More...</a><br/></td></tr>
<tr class="separator:a59e7b1c395b14af00409d9ca3ee4a687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff82ceb2b15cc6592d74bc48a8542588"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff82ceb2b15cc6592d74bc48a8542588"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a00205.html">Rot3</a> &amp;R)</td></tr>
<tr class="separator:aff82ceb2b15cc6592d74bc48a8542588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6a2b4b6a6423eb8c49ae4fad1ef790"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b6a2b4b6a6423eb8c49ae4fad1ef790"></a>
<a class="el" href="a00290.html#a7bb03eb3dceb63b0933c94c15b83cb39">SimpleCamera</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a9b6a2b4b6a6423eb8c49ae4fad1ef790">simpleCamera</a> (const Matrix &amp;P)</td></tr>
<tr class="memdesc:a9b6a2b4b6a6423eb8c49ae4fad1ef790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover camera from 3*4 camera matrix. <br/></td></tr>
<tr class="separator:a9b6a2b4b6a6423eb8c49ae4fad1ef790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac774d6d37c142606e84487c9905c02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00187.html">Point3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#afac774d6d37c142606e84487c9905c02">triangulateDLT</a> (const std::vector&lt; Matrix &gt; &amp;projection_matrices, const std::vector&lt; <a class="el" href="a00186.html">Point2</a> &gt; &amp;measurements, double rank_tol)</td></tr>
<tr class="memdesc:afac774d6d37c142606e84487c9905c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">DLT triangulation: See Hartley and Zisserman, 2nd Ed., page 312.  <a href="#afac774d6d37c142606e84487c9905c02">More...</a><br/></td></tr>
<tr class="separator:afac774d6d37c142606e84487c9905c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0057879b0c5f323185452b0d1a4232"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00187.html">Point3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a4b0057879b0c5f323185452b0d1a4232">optimize</a> (const <a class="el" href="a00173.html">NonlinearFactorGraph</a> &amp;graph, const <a class="el" href="a00244.html">Values</a> &amp;values, <a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> landmarkKey)</td></tr>
<tr class="memdesc:a4b0057879b0c5f323185452b0d1a4232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize for triangulation.  <a href="#a4b0057879b0c5f323185452b0d1a4232">More...</a><br/></td></tr>
<tr class="separator:a4b0057879b0c5f323185452b0d1a4232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53edb52916aae7593c671cf5a241939"><td class="memTemplParams" colspan="2">template&lt;class CALIBRATION &gt; </td></tr>
<tr class="memitem:ab53edb52916aae7593c671cf5a241939"><td class="memTemplItemLeft" align="right" valign="top">std::pair<br class="typebreak"/>
&lt; <a class="el" href="a00173.html">NonlinearFactorGraph</a>, <a class="el" href="a00244.html">Values</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#ab53edb52916aae7593c671cf5a241939">triangulationGraph</a> (const std::vector&lt; <a class="el" href="a00189.html">Pose3</a> &gt; &amp;poses, boost::shared_ptr&lt; CALIBRATION &gt; sharedCal, const std::vector&lt; <a class="el" href="a00186.html">Point2</a> &gt; &amp;measurements, <a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> landmarkKey, const <a class="el" href="a00187.html">Point3</a> &amp;initialEstimate)</td></tr>
<tr class="memdesc:ab53edb52916aae7593c671cf5a241939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a factor graph with projection factors from poses and one calibration.  <a href="#ab53edb52916aae7593c671cf5a241939">More...</a><br/></td></tr>
<tr class="separator:ab53edb52916aae7593c671cf5a241939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7177920d6b77c685fec4178a79eeb830"><td class="memTemplParams" colspan="2">template&lt;class CALIBRATION &gt; </td></tr>
<tr class="memitem:a7177920d6b77c685fec4178a79eeb830"><td class="memTemplItemLeft" align="right" valign="top">std::pair<br class="typebreak"/>
&lt; <a class="el" href="a00173.html">NonlinearFactorGraph</a>, <a class="el" href="a00244.html">Values</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a7177920d6b77c685fec4178a79eeb830">triangulationGraph</a> (const std::vector&lt; <a class="el" href="a00185.html">PinholeCamera</a>&lt; CALIBRATION &gt; &gt; &amp;cameras, const std::vector&lt; <a class="el" href="a00186.html">Point2</a> &gt; &amp;measurements, <a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> landmarkKey, const <a class="el" href="a00187.html">Point3</a> &amp;initialEstimate)</td></tr>
<tr class="memdesc:a7177920d6b77c685fec4178a79eeb830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a factor graph with projection factors from pinhole cameras (each camera has a pose and calibration)  <a href="#a7177920d6b77c685fec4178a79eeb830">More...</a><br/></td></tr>
<tr class="separator:a7177920d6b77c685fec4178a79eeb830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65edc51013011a97850fbe1684da14c9"><td class="memTemplParams" colspan="2">template&lt;class CALIBRATION &gt; </td></tr>
<tr class="memitem:a65edc51013011a97850fbe1684da14c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00187.html">Point3</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a65edc51013011a97850fbe1684da14c9">triangulateNonlinear</a> (const std::vector&lt; <a class="el" href="a00189.html">Pose3</a> &gt; &amp;poses, boost::shared_ptr&lt; CALIBRATION &gt; sharedCal, const std::vector&lt; <a class="el" href="a00186.html">Point2</a> &gt; &amp;measurements, const <a class="el" href="a00187.html">Point3</a> &amp;initialEstimate)</td></tr>
<tr class="memdesc:a65edc51013011a97850fbe1684da14c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an initial estimate , refine a point using measurements in several cameras.  <a href="#a65edc51013011a97850fbe1684da14c9">More...</a><br/></td></tr>
<tr class="separator:a65edc51013011a97850fbe1684da14c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a7e844788f256cb7461d2d8a42e0ae"><td class="memTemplParams" colspan="2">template&lt;class CALIBRATION &gt; </td></tr>
<tr class="memitem:a50a7e844788f256cb7461d2d8a42e0ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00187.html">Point3</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a50a7e844788f256cb7461d2d8a42e0ae">triangulateNonlinear</a> (const std::vector&lt; <a class="el" href="a00185.html">PinholeCamera</a>&lt; CALIBRATION &gt; &gt; &amp;cameras, const std::vector&lt; <a class="el" href="a00186.html">Point2</a> &gt; &amp;measurements, const <a class="el" href="a00187.html">Point3</a> &amp;initialEstimate)</td></tr>
<tr class="memdesc:a50a7e844788f256cb7461d2d8a42e0ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an initial estimate , refine a point using measurements in several cameras.  <a href="#a50a7e844788f256cb7461d2d8a42e0ae">More...</a><br/></td></tr>
<tr class="separator:a50a7e844788f256cb7461d2d8a42e0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74917d865d97c3675a9358519dd28fbf"><td class="memTemplParams" colspan="2">template&lt;class CALIBRATION &gt; </td></tr>
<tr class="memitem:a74917d865d97c3675a9358519dd28fbf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00187.html">Point3</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a74917d865d97c3675a9358519dd28fbf">triangulatePoint3</a> (const std::vector&lt; <a class="el" href="a00189.html">Pose3</a> &gt; &amp;poses, boost::shared_ptr&lt; CALIBRATION &gt; sharedCal, const std::vector&lt; <a class="el" href="a00186.html">Point2</a> &gt; &amp;measurements, double rank_tol=1e-9, bool optimize=false)</td></tr>
<tr class="memdesc:a74917d865d97c3675a9358519dd28fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to triangulate 3D landmark point from an arbitrary number of poses (at least 2) using the DLT.  <a href="#a74917d865d97c3675a9358519dd28fbf">More...</a><br/></td></tr>
<tr class="separator:a74917d865d97c3675a9358519dd28fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df4caa55f658b412f9c817975cb8aca"><td class="memTemplParams" colspan="2">template&lt;class CALIBRATION &gt; </td></tr>
<tr class="memitem:a0df4caa55f658b412f9c817975cb8aca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00187.html">Point3</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a0df4caa55f658b412f9c817975cb8aca">triangulatePoint3</a> (const std::vector&lt; <a class="el" href="a00185.html">PinholeCamera</a>&lt; CALIBRATION &gt; &gt; &amp;cameras, const std::vector&lt; <a class="el" href="a00186.html">Point2</a> &gt; &amp;measurements, double rank_tol=1e-9, bool optimize=false)</td></tr>
<tr class="memdesc:a0df4caa55f658b412f9c817975cb8aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to triangulate 3D landmark point from an arbitrary number of poses (at least 2) using the DLT.  <a href="#a0df4caa55f658b412f9c817975cb8aca">More...</a><br/></td></tr>
<tr class="separator:a0df4caa55f658b412f9c817975cb8aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81e78a9bbb281668fedfd68009ec550"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad81e78a9bbb281668fedfd68009ec550"></a>
template&lt;class CLIQUE &gt; </td></tr>
<tr class="memitem:ad81e78a9bbb281668fedfd68009ec550"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>check_sharedCliques</b> (const std::pair&lt; <a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a>, typename <a class="el" href="a00010.html">BayesTree</a>&lt; CLIQUE &gt;::sharedClique &gt; &amp;v1, const std::pair&lt; <a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a>, typename <a class="el" href="a00010.html">BayesTree</a>&lt; CLIQUE &gt;::sharedClique &gt; &amp;v2)</td></tr>
<tr class="separator:ad81e78a9bbb281668fedfd68009ec550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a265afdea057ea54be10262396be12"><td class="memTemplParams" colspan="2"><a class="anchor" id="a18a265afdea057ea54be10262396be12"></a>
template&lt;class KEY &gt; </td></tr>
<tr class="memitem:a18a265afdea057ea54be10262396be12"><td class="memTemplItemLeft" align="right" valign="top">std::list&lt; KEY &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a18a265afdea057ea54be10262396be12">predecessorMap2Keys</a> (const <a class="el" href="a00194.html">PredecessorMap</a>&lt; KEY &gt; &amp;p_map)</td></tr>
<tr class="memdesc:a18a265afdea057ea54be10262396be12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a list of keys from a spanning tree represented by its predecessor map. <br/></td></tr>
<tr class="separator:a18a265afdea057ea54be10262396be12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0319a6ebcc83d4a5cf9ff51729bb80"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6c0319a6ebcc83d4a5cf9ff51729bb80"></a>
template&lt;class G , class F , class KEY &gt; </td></tr>
<tr class="memitem:a6c0319a6ebcc83d4a5cf9ff51729bb80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00211.html">SDGraph</a>&lt; KEY &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a6c0319a6ebcc83d4a5cf9ff51729bb80">toBoostGraph</a> (const G &amp;graph)</td></tr>
<tr class="memdesc:a6c0319a6ebcc83d4a5cf9ff51729bb80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the factor graph to an <a class="el" href="a00211.html" title="SDGraph is undirected graph with variable keys and double edge weights.">SDGraph</a> G = Graph type F = <a class="el" href="a00082.html" title="This is the base class for all factor types.">Factor</a> type Key = Key type. <br/></td></tr>
<tr class="separator:a6c0319a6ebcc83d4a5cf9ff51729bb80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67d0d86c4e55b175859967a70b36983"><td class="memTemplParams" colspan="2">template&lt;class G , class V , class KEY &gt; </td></tr>
<tr class="memitem:ae67d0d86c4e55b175859967a70b36983"><td class="memTemplItemLeft" align="right" valign="top">boost::tuple&lt; G, V, std::map<br class="typebreak"/>
&lt; KEY, V &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#ae67d0d86c4e55b175859967a70b36983">predecessorMap2Graph</a> (const <a class="el" href="a00194.html">PredecessorMap</a>&lt; KEY &gt; &amp;p_map)</td></tr>
<tr class="memdesc:ae67d0d86c4e55b175859967a70b36983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build takes a predecessor map, and builds a directed graph corresponding to the tree.  <a href="#ae67d0d86c4e55b175859967a70b36983">More...</a><br/></td></tr>
<tr class="separator:ae67d0d86c4e55b175859967a70b36983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b34d6038ccdfa84d8a5bb0c15328b1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a62b34d6038ccdfa84d8a5bb0c15328b1"></a>
template&lt;class G , class Factor , class POSE , class KEY &gt; </td></tr>
<tr class="memitem:a62b34d6038ccdfa84d8a5bb0c15328b1"><td class="memTemplItemLeft" align="right" valign="top">boost::shared_ptr&lt; <a class="el" href="a00244.html">Values</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a62b34d6038ccdfa84d8a5bb0c15328b1">composePoses</a> (const G &amp;graph, const <a class="el" href="a00194.html">PredecessorMap</a>&lt; KEY &gt; &amp;tree, const POSE &amp;rootPose)</td></tr>
<tr class="memdesc:a62b34d6038ccdfa84d8a5bb0c15328b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose the poses by following the chain specified by the spanning tree. <br/></td></tr>
<tr class="separator:a62b34d6038ccdfa84d8a5bb0c15328b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7771a103b41708e88763ff67059ff01d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7771a103b41708e88763ff67059ff01d"></a>
template&lt;class G , class KEY , class FACTOR2 &gt; </td></tr>
<tr class="memitem:a7771a103b41708e88763ff67059ff01d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00194.html">PredecessorMap</a>&lt; KEY &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a7771a103b41708e88763ff67059ff01d">findMinimumSpanningTree</a> (const G &amp;g)</td></tr>
<tr class="memdesc:a7771a103b41708e88763ff67059ff01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the minimum spanning tree using boost graph library <br/></td></tr>
<tr class="separator:a7771a103b41708e88763ff67059ff01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3453247aec1d8b4642947ffd4bca426b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3453247aec1d8b4642947ffd4bca426b"></a>
template&lt;class G , class KEY , class FACTOR2 &gt; </td></tr>
<tr class="memitem:a3453247aec1d8b4642947ffd4bca426b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a3453247aec1d8b4642947ffd4bca426b">split</a> (const G &amp;g, const <a class="el" href="a00194.html">PredecessorMap</a>&lt; KEY &gt; &amp;tree, G &amp;Ab1, G &amp;Ab2)</td></tr>
<tr class="memdesc:a3453247aec1d8b4642947ffd4bca426b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the graph into two parts: one corresponds to the given spanning tree, and the other corresponds to the rest of the factors. <br/></td></tr>
<tr class="separator:a3453247aec1d8b4642947ffd4bca426b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378dab7dd4f60f820d0bcb638542812a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a378dab7dd4f60f820d0bcb638542812a"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>_multirobotKeyFormatter</b> (<a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> key)</td></tr>
<tr class="separator:a378dab7dd4f60f820d0bcb638542812a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9018bf07bb2a775fa71c7644a18aea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d9018bf07bb2a775fa71c7644a18aea"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a9d9018bf07bb2a775fa71c7644a18aea">printKeyList</a> (const <a class="el" href="a00290.html#a6fcb28bfc2908ca506aa5503f24b4c8f">KeyList</a> &amp;keys, const std::string &amp;s=&quot;&quot;, const <a class="el" href="a00290.html#a29dee574fe60f586d71b2c0d957dc8bb">KeyFormatter</a> &amp;keyFormatter=DefaultKeyFormatter)</td></tr>
<tr class="memdesc:a9d9018bf07bb2a775fa71c7644a18aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to print sets of keys with optional prefix. <br/></td></tr>
<tr class="separator:a9d9018bf07bb2a775fa71c7644a18aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74bf98926482dc49ad99ee1a5269e586"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74bf98926482dc49ad99ee1a5269e586"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a74bf98926482dc49ad99ee1a5269e586">printKeyVector</a> (const <a class="el" href="a00092.html">KeyVector</a> &amp;keys, const std::string &amp;s=&quot;&quot;, const <a class="el" href="a00290.html#a29dee574fe60f586d71b2c0d957dc8bb">KeyFormatter</a> &amp;keyFormatter=DefaultKeyFormatter)</td></tr>
<tr class="memdesc:a74bf98926482dc49ad99ee1a5269e586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to print sets of keys with optional prefix. <br/></td></tr>
<tr class="separator:a74bf98926482dc49ad99ee1a5269e586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a7273226ed73c077b6d6ea45b68e2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36a7273226ed73c077b6d6ea45b68e2e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a36a7273226ed73c077b6d6ea45b68e2e">printKeySet</a> (const <a class="el" href="a00089.html">KeySet</a> &amp;keys, const std::string &amp;s=&quot;&quot;, const <a class="el" href="a00290.html#a29dee574fe60f586d71b2c0d957dc8bb">KeyFormatter</a> &amp;keyFormatter=DefaultKeyFormatter)</td></tr>
<tr class="memdesc:a36a7273226ed73c077b6d6ea45b68e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to print sets of keys with optional prefix. <br/></td></tr>
<tr class="separator:a36a7273226ed73c077b6d6ea45b68e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a7dceb0a85c356062b55f6939b1419"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ae9a7dceb0a85c356062b55f6939b1419">mrsymbol</a> (unsigned char c, unsigned char label, size_t j)</td></tr>
<tr class="memdesc:ae9a7dceb0a85c356062b55f6939b1419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a symbol key from a character, label and index, i.e.  <a href="#ae9a7dceb0a85c356062b55f6939b1419">More...</a><br/></td></tr>
<tr class="separator:ae9a7dceb0a85c356062b55f6939b1419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37995b0d0610e5fb29c6bd0715151d67"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a37995b0d0610e5fb29c6bd0715151d67">mrsymbolChr</a> (<a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> key)</td></tr>
<tr class="memdesc:a37995b0d0610e5fb29c6bd0715151d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the character portion of a symbol key.  <a href="#a37995b0d0610e5fb29c6bd0715151d67">More...</a><br/></td></tr>
<tr class="separator:a37995b0d0610e5fb29c6bd0715151d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4c133c4fd0d9d73593f601be2248a6"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a4e4c133c4fd0d9d73593f601be2248a6">mrsymbolLabel</a> (<a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> key)</td></tr>
<tr class="memdesc:a4e4c133c4fd0d9d73593f601be2248a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the label portion of a symbol key.  <a href="#a4e4c133c4fd0d9d73593f601be2248a6">More...</a><br/></td></tr>
<tr class="separator:a4e4c133c4fd0d9d73593f601be2248a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adc1bb606fa4a14d5dbd246f95cecd3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a4adc1bb606fa4a14d5dbd246f95cecd3">mrsymbolIndex</a> (<a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> key)</td></tr>
<tr class="memdesc:a4adc1bb606fa4a14d5dbd246f95cecd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index portion of a symbol key.  <a href="#a4adc1bb606fa4a14d5dbd246f95cecd3">More...</a><br/></td></tr>
<tr class="separator:a4adc1bb606fa4a14d5dbd246f95cecd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd266db68d8146af3b9b1630d4b700b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a7cd266db68d8146af3b9b1630d4b700b">symbol</a> (unsigned char c, size_t j)</td></tr>
<tr class="memdesc:a7cd266db68d8146af3b9b1630d4b700b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a symbol key from a character and index, i.e.  <a href="#a7cd266db68d8146af3b9b1630d4b700b">More...</a><br/></td></tr>
<tr class="separator:a7cd266db68d8146af3b9b1630d4b700b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca9499e881d22361b4833c2854d941f"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a9ca9499e881d22361b4833c2854d941f">symbolChr</a> (<a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> key)</td></tr>
<tr class="memdesc:a9ca9499e881d22361b4833c2854d941f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the character portion of a symbol key.  <a href="#a9ca9499e881d22361b4833c2854d941f">More...</a><br/></td></tr>
<tr class="separator:a9ca9499e881d22361b4833c2854d941f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901c06d89d5c4ba46d926a86b307f271"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a901c06d89d5c4ba46d926a86b307f271">symbolIndex</a> (<a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> key)</td></tr>
<tr class="memdesc:a901c06d89d5c4ba46d926a86b307f271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index portion of a symbol key.  <a href="#a901c06d89d5c4ba46d926a86b307f271">More...</a><br/></td></tr>
<tr class="separator:a901c06d89d5c4ba46d926a86b307f271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35831074a7aab15d463acddc7767bfe8"><td class="memTemplParams" colspan="2">template&lt;typename L &gt; </td></tr>
<tr class="memitem:a35831074a7aab15d463acddc7767bfe8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a00005.html">Assignment</a>&lt; L &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a35831074a7aab15d463acddc7767bfe8">cartesianProduct</a> (const std::vector&lt; std::pair&lt; L, size_t &gt; &gt; &amp;keys)</td></tr>
<tr class="memdesc:a35831074a7aab15d463acddc7767bfe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Cartesian product consisting all possible configurations.  <a href="#a35831074a7aab15d463acddc7767bfe8">More...</a><br/></td></tr>
<tr class="separator:a35831074a7aab15d463acddc7767bfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf36c31dcf9f45f5bbdfd2b80f07cd1f"><td class="memTemplParams" colspan="2"><a class="anchor" id="abf36c31dcf9f45f5bbdfd2b80f07cd1f"></a>
template&lt;typename Y , typename L &gt; </td></tr>
<tr class="memitem:abf36c31dcf9f45f5bbdfd2b80f07cd1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00046.html">DecisionTree</a>&lt; L, Y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#abf36c31dcf9f45f5bbdfd2b80f07cd1f">apply</a> (const <a class="el" href="a00046.html">DecisionTree</a>&lt; L, Y &gt; &amp;f, const typename <a class="el" href="a00046.html">DecisionTree</a>&lt; L, Y &gt;::Unary &amp;op)</td></tr>
<tr class="memdesc:abf36c31dcf9f45f5bbdfd2b80f07cd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">free versions of apply <br/></td></tr>
<tr class="separator:abf36c31dcf9f45f5bbdfd2b80f07cd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa0c47ab0d861b59ac13096141b7b0d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3aa0c47ab0d861b59ac13096141b7b0d"></a>
template&lt;typename Y , typename L &gt; </td></tr>
<tr class="memitem:a3aa0c47ab0d861b59ac13096141b7b0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00046.html">DecisionTree</a>&lt; L, Y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply</b> (const <a class="el" href="a00046.html">DecisionTree</a>&lt; L, Y &gt; &amp;f, const <a class="el" href="a00046.html">DecisionTree</a>&lt; L, Y &gt; &amp;g, const typename <a class="el" href="a00046.html">DecisionTree</a>&lt; L, Y &gt;::Binary &amp;op)</td></tr>
<tr class="separator:a3aa0c47ab0d861b59ac13096141b7b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0767417e558bbac14f3b27bc54d033e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0767417e558bbac14f3b27bc54d033e9"></a>
std::pair<br class="typebreak"/>
&lt; <a class="el" href="a00054.html#a4d8b3999aa607019946cbcfd255c09dd">DiscreteConditional::shared_ptr</a>, <br class="typebreak"/>
DecisionTreeFactor::shared_ptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a0767417e558bbac14f3b27bc54d033e9">EliminateDiscrete</a> (const <a class="el" href="a00057.html">DiscreteFactorGraph</a> &amp;factors, const <a class="el" href="a00181.html">Ordering</a> &amp;keys)</td></tr>
<tr class="memdesc:a0767417e558bbac14f3b27bc54d033e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main elimination function for <a class="el" href="a00057.html" title="A Discrete Factor Graph is a factor graph where all factors are Discrete, i.e.">DiscreteFactorGraph</a>. <br/></td></tr>
<tr class="separator:a0767417e558bbac14f3b27bc54d033e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be4f243161c2fd937df60aee511eb16"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0be4f243161c2fd937df60aee511eb16"></a>
<a class="el" href="a00059.html">DiscreteKeys</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a0be4f243161c2fd937df60aee511eb16">operator&amp;</a> (const <a class="el" href="a00290.html#acd19e5d1e5d06c37246d4c15af38ee67">DiscreteKey</a> &amp;key1, const <a class="el" href="a00290.html#acd19e5d1e5d06c37246d4c15af38ee67">DiscreteKey</a> &amp;key2)</td></tr>
<tr class="memdesc:a0be4f243161c2fd937df60aee511eb16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a list from two keys. <br/></td></tr>
<tr class="separator:a0be4f243161c2fd937df60aee511eb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c37843912deeded5d819732ae2152a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c37843912deeded5d819732ae2152a7"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a00215.html#a058b129adfd1cdb887c88efedf2c8ca3">Signature::Row</a> &amp;<a class="el" href="a00290.html#a2754f325c8600303d627d9e8cf1f9949">row</a>)</td></tr>
<tr class="separator:a8c37843912deeded5d819732ae2152a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488af348118a5965a2e4142c9cd6ba42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a488af348118a5965a2e4142c9cd6ba42"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const Signature::Table &amp;table)</td></tr>
<tr class="separator:a488af348118a5965a2e4142c9cd6ba42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada56b99f564432dcf54a04a0db7dd178"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada56b99f564432dcf54a04a0db7dd178"></a>
ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (ostream &amp;os, const <a class="el" href="a00215.html">Signature</a> &amp;s)</td></tr>
<tr class="separator:ada56b99f564432dcf54a04a0db7dd178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c58dfb2fc9398a026e3268ba2edfad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6c58dfb2fc9398a026e3268ba2edfad"></a>
<a class="el" href="a00215.html">Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#aa6c58dfb2fc9398a026e3268ba2edfad">operator|</a> (const <a class="el" href="a00290.html#acd19e5d1e5d06c37246d4c15af38ee67">DiscreteKey</a> &amp;key, const <a class="el" href="a00290.html#acd19e5d1e5d06c37246d4c15af38ee67">DiscreteKey</a> &amp;parent)</td></tr>
<tr class="memdesc:aa6c58dfb2fc9398a026e3268ba2edfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create <a class="el" href="a00215.html" title="Signature for a discrete conditional density, used to construct conditionals.">Signature</a> objects example: <a class="el" href="a00215.html" title="Signature for a discrete conditional density, used to construct conditionals.">Signature</a> s = D | E;. <br/></td></tr>
<tr class="separator:aa6c58dfb2fc9398a026e3268ba2edfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98cf2a4777006c28d6983db5d8ec574"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab98cf2a4777006c28d6983db5d8ec574"></a>
<a class="el" href="a00215.html">Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ab98cf2a4777006c28d6983db5d8ec574">operator%</a> (const <a class="el" href="a00290.html#acd19e5d1e5d06c37246d4c15af38ee67">DiscreteKey</a> &amp;key, const std::string &amp;parent)</td></tr>
<tr class="memdesc:ab98cf2a4777006c28d6983db5d8ec574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create <a class="el" href="a00215.html" title="Signature for a discrete conditional density, used to construct conditionals.">Signature</a> objects example: <a class="el" href="a00215.html" title="Signature for a discrete conditional density, used to construct conditionals.">Signature</a> s(D % "99/1"); Uses string parser, which requires BOOST 1.42 or higher. <br/></td></tr>
<tr class="separator:ab98cf2a4777006c28d6983db5d8ec574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4856250df52ce4b9b4b16c7a833408c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4856250df52ce4b9b4b16c7a833408c"></a>
<a class="el" href="a00215.html">Signature</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ae4856250df52ce4b9b4b16c7a833408c">operator%</a> (const <a class="el" href="a00290.html#acd19e5d1e5d06c37246d4c15af38ee67">DiscreteKey</a> &amp;key, const Signature::Table &amp;parent)</td></tr>
<tr class="memdesc:ae4856250df52ce4b9b4b16c7a833408c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create <a class="el" href="a00215.html" title="Signature for a discrete conditional density, used to construct conditionals.">Signature</a> objects, using table construction directly example: <a class="el" href="a00215.html" title="Signature for a discrete conditional density, used to construct conditionals.">Signature</a> s(D % table);. <br/></td></tr>
<tr class="separator:ae4856250df52ce4b9b4b16c7a833408c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106ec458ddb425604809da93346af55d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a106ec458ddb425604809da93346af55d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a106ec458ddb425604809da93346af55d">dot</a> (const <a class="el" href="a00075.html">Errors</a> &amp;a, const <a class="el" href="a00075.html">Errors</a> &amp;b)</td></tr>
<tr class="memdesc:a106ec458ddb425604809da93346af55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">dot product <br/></td></tr>
<tr class="separator:a106ec458ddb425604809da93346af55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af191b77091843947b9ae5c413d8caf27"><td class="memTemplParams" colspan="2"><a class="anchor" id="af191b77091843947b9ae5c413d8caf27"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:af191b77091843947b9ae5c413d8caf27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#af191b77091843947b9ae5c413d8caf27">axpy&lt; Errors, Errors &gt;</a> (double alpha, const <a class="el" href="a00075.html">Errors</a> &amp;x, <a class="el" href="a00075.html">Errors</a> &amp;y)</td></tr>
<tr class="memdesc:af191b77091843947b9ae5c413d8caf27"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS level 2 style. <br/></td></tr>
<tr class="separator:af191b77091843947b9ae5c413d8caf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9528f84279a6f9c18d7d5a444735e57a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9528f84279a6f9c18d7d5a444735e57a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a9528f84279a6f9c18d7d5a444735e57a">print</a> (const <a class="el" href="a00075.html">Errors</a> &amp;a, const std::string &amp;s=&quot;Error&quot;)</td></tr>
<tr class="memdesc:a9528f84279a6f9c18d7d5a444735e57a"><td class="mdescLeft">&#160;</td><td class="mdescRight">print with optional string <br/></td></tr>
<tr class="separator:a9528f84279a6f9c18d7d5a444735e57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939e1342568a5072310bc7995d3cf383"><td class="memTemplParams" colspan="2"><a class="anchor" id="a939e1342568a5072310bc7995d3cf383"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a939e1342568a5072310bc7995d3cf383"><td class="memTemplItemLeft" align="right" valign="top">GTSAM_EXPORT void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a939e1342568a5072310bc7995d3cf383">axpy&lt; Errors, Errors &gt;</a> (double alpha, const <a class="el" href="a00075.html">Errors</a> &amp;x, <a class="el" href="a00075.html">Errors</a> &amp;y)</td></tr>
<tr class="memdesc:a939e1342568a5072310bc7995d3cf383"><td class="mdescLeft">&#160;</td><td class="mdescRight">BLAS level 2 style. <br/></td></tr>
<tr class="separator:a939e1342568a5072310bc7995d3cf383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c269c3243cab16a7475239a9c91021"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a35c269c3243cab16a7475239a9c91021">hasConstraints</a> (const <a class="el" href="a00103.html">GaussianFactorGraph</a> &amp;factors)</td></tr>
<tr class="memdesc:a35c269c3243cab16a7475239a9c91021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates whether linear factors have any constrained noise models.  <a href="#a35c269c3243cab16a7475239a9c91021">More...</a><br/></td></tr>
<tr class="separator:a35c269c3243cab16a7475239a9c91021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37760d3ca31c6d8d60a3a2a17babc3a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37760d3ca31c6d8d60a3a2a17babc3a4"></a>
std::pair&lt; boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="a00099.html">GaussianConditional</a> &gt;<br class="typebreak"/>
, boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="a00115.html">HessianFactor</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EliminateCholesky</b> (const <a class="el" href="a00103.html">GaussianFactorGraph</a> &amp;factors, const <a class="el" href="a00181.html">Ordering</a> &amp;keys)</td></tr>
<tr class="separator:a37760d3ca31c6d8d60a3a2a17babc3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb147d2a9039f67ad3b8b5515d2e5cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbb147d2a9039f67ad3b8b5515d2e5cc"></a>
std::pair&lt; boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="a00099.html">GaussianConditional</a> &gt;<br class="typebreak"/>
, boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="a00102.html">GaussianFactor</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EliminatePreferCholesky</b> (const <a class="el" href="a00103.html">GaussianFactorGraph</a> &amp;factors, const <a class="el" href="a00181.html">Ordering</a> &amp;keys)</td></tr>
<tr class="separator:adbb147d2a9039f67ad3b8b5515d2e5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6516ea957c3a22ddf429cefef1fe9486"><td class="memTemplParams" colspan="2">template&lt;class S , class V , class E &gt; </td></tr>
<tr class="memitem:a6516ea957c3a22ddf429cefef1fe9486"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a6516ea957c3a22ddf429cefef1fe9486">conjugateGradients</a> (const S &amp;Ab, V x, const <a class="el" href="a00037.html">ConjugateGradientParameters</a> &amp;parameters, bool steepest=false)</td></tr>
<tr class="memdesc:a6516ea957c3a22ddf429cefef1fe9486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method of conjugate gradients (CG) template "System" class S needs gradient(S,v), e=S*v, v=S^e "Vector" class V needs dot(v,v), -v, v+v, s*v "Vector" class E needs dot(v,v)  <a href="#a6516ea957c3a22ddf429cefef1fe9486">More...</a><br/></td></tr>
<tr class="separator:a6516ea957c3a22ddf429cefef1fe9486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dffaf102d7e9efcaea199e4cc2e95e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0dffaf102d7e9efcaea199e4cc2e95e3"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><b>steepestDescent</b> (const <a class="el" href="a00230.html">System</a> &amp;Ab, const Vector &amp;x, const <a class="el" href="a00037.html">ConjugateGradientParameters</a> &amp;parameters)</td></tr>
<tr class="separator:a0dffaf102d7e9efcaea199e4cc2e95e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b587fde5d35a27d6c88feb4432e785"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2b587fde5d35a27d6c88feb4432e785"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ad2b587fde5d35a27d6c88feb4432e785">conjugateGradientDescent</a> (const <a class="el" href="a00230.html">System</a> &amp;Ab, const Vector &amp;x, const <a class="el" href="a00037.html">ConjugateGradientParameters</a> &amp;parameters)</td></tr>
<tr class="memdesc:ad2b587fde5d35a27d6c88feb4432e785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method of conjugate gradients (CG), <a class="el" href="a00230.html" title="Helper class encapsulating the combined system |Ax-b_|^2 Needed to run Conjugate Gradients on matrice...">System</a> version. <br/></td></tr>
<tr class="separator:ad2b587fde5d35a27d6c88feb4432e785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4b2ca704ddd6530ea70122f883ac88"><td class="memItemLeft" align="right" valign="top">Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#aed4b2ca704ddd6530ea70122f883ac88">steepestDescent</a> (const Matrix &amp;A, const Vector &amp;b, const Vector &amp;x, const <a class="el" href="a00037.html">ConjugateGradientParameters</a> &amp;parameters)</td></tr>
<tr class="memdesc:aed4b2ca704ddd6530ea70122f883ac88"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience calls using matrices, will create <a class="el" href="a00230.html" title="Helper class encapsulating the combined system |Ax-b_|^2 Needed to run Conjugate Gradients on matrice...">System</a> class internally:  <a href="#aed4b2ca704ddd6530ea70122f883ac88">More...</a><br/></td></tr>
<tr class="separator:aed4b2ca704ddd6530ea70122f883ac88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55440f741d8b2f706101f7a79ba7111"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af55440f741d8b2f706101f7a79ba7111"></a>
Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#af55440f741d8b2f706101f7a79ba7111">conjugateGradientDescent</a> (const Matrix &amp;A, const Vector &amp;b, const Vector &amp;x, const <a class="el" href="a00037.html">ConjugateGradientParameters</a> &amp;parameters)</td></tr>
<tr class="memdesc:af55440f741d8b2f706101f7a79ba7111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method of conjugate gradients (CG), Matrix version. <br/></td></tr>
<tr class="separator:af55440f741d8b2f706101f7a79ba7111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b7af7638d28555c3f404318cc67b22"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81b7af7638d28555c3f404318cc67b22"></a>
<a class="el" href="a00252.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a81b7af7638d28555c3f404318cc67b22">steepestDescent</a> (const <a class="el" href="a00103.html">GaussianFactorGraph</a> &amp;fg, const <a class="el" href="a00252.html">VectorValues</a> &amp;x, const <a class="el" href="a00037.html">ConjugateGradientParameters</a> &amp;parameters)</td></tr>
<tr class="memdesc:a81b7af7638d28555c3f404318cc67b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method of steepest gradients, Gaussian <a class="el" href="a00082.html" title="This is the base class for all factor types.">Factor</a> Graph version. <br/></td></tr>
<tr class="separator:a81b7af7638d28555c3f404318cc67b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84114ad1593684ad739088a2898afdb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa84114ad1593684ad739088a2898afdb"></a>
<a class="el" href="a00252.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#aa84114ad1593684ad739088a2898afdb">conjugateGradientDescent</a> (const <a class="el" href="a00103.html">GaussianFactorGraph</a> &amp;fg, const <a class="el" href="a00252.html">VectorValues</a> &amp;x, const <a class="el" href="a00037.html">ConjugateGradientParameters</a> &amp;parameters)</td></tr>
<tr class="memdesc:aa84114ad1593684ad739088a2898afdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method of conjugate gradients (CG), Gaussian <a class="el" href="a00082.html" title="This is the base class for all factor types.">Factor</a> Graph version. <br/></td></tr>
<tr class="separator:aa84114ad1593684ad739088a2898afdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ca85391e3bc671c71b68bc324296f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37ca85391e3bc671c71b68bc324296f0"></a>
GTSAM_EXPORT Vector&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a37ca85391e3bc671c71b68bc324296f0">steepestDescent</a> (const <a class="el" href="a00230.html">System</a> &amp;Ab, const Vector &amp;x, const <a class="el" href="a00133.html">IterativeOptimizationParameters</a> &amp;parameters)</td></tr>
<tr class="memdesc:a37ca85391e3bc671c71b68bc324296f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method of steepest gradients, <a class="el" href="a00230.html" title="Helper class encapsulating the combined system |Ax-b_|^2 Needed to run Conjugate Gradients on matrice...">System</a> version. <br/></td></tr>
<tr class="separator:a37ca85391e3bc671c71b68bc324296f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56c4bfa363f8c23c48eb078e9c84a9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab56c4bfa363f8c23c48eb078e9c84a9c"></a>
std::pair&lt; boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="a00099.html">GaussianConditional</a> &gt;<br class="typebreak"/>
, boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="a00135.html">JacobianFactor</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>EliminateQR</b> (const <a class="el" href="a00103.html">GaussianFactorGraph</a> &amp;factors, const <a class="el" href="a00181.html">Ordering</a> &amp;keys)</td></tr>
<tr class="separator:ab56c4bfa363f8c23c48eb078e9c84a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131393739a049cb8d3c3d0c3c6e960d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00252.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a131393739a049cb8d3c3d0c3c6e960d6">operator*</a> (const double a, const <a class="el" href="a00252.html">VectorValues</a> &amp;v)</td></tr>
<tr class="separator:a131393739a049cb8d3c3d0c3c6e960d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f7dce2bbe9daf6b24ad2b38916fc5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a37f7dce2bbe9daf6b24ad2b38916fc5f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CheckRelinearizationRecursiveDouble</b> (<a class="el" href="a00089.html">FastSet</a>&lt; <a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> &gt; &amp;relinKeys, double threshold, const <a class="el" href="a00252.html">VectorValues</a> &amp;<a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>, const ISAM2Clique::shared_ptr &amp;clique)</td></tr>
<tr class="separator:a37f7dce2bbe9daf6b24ad2b38916fc5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0d9332272d4fb2115986b41e91b1e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b0d9332272d4fb2115986b41e91b1e5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CheckRelinearizationRecursiveMap</b> (<a class="el" href="a00089.html">FastSet</a>&lt; <a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> &gt; &amp;relinKeys, const <a class="el" href="a00088.html">FastMap</a>&lt; char, Vector &gt; &amp;thresholds, const <a class="el" href="a00252.html">VectorValues</a> &amp;<a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>, const ISAM2Clique::shared_ptr &amp;clique)</td></tr>
<tr class="separator:a9b0d9332272d4fb2115986b41e91b1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33509e7a55b46fe677e682d01f8fbd87"><td class="memTemplParams" colspan="2">template&lt;class CLIQUE &gt; </td></tr>
<tr class="memitem:a33509e7a55b46fe677e682d01f8fbd87"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a33509e7a55b46fe677e682d01f8fbd87">optimizeWildfire</a> (const boost::shared_ptr&lt; CLIQUE &gt; &amp;root, double threshold, const <a class="el" href="a00089.html">FastSet</a>&lt; <a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> &gt; &amp;replaced, <a class="el" href="a00252.html">VectorValues</a> &amp;<a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>)</td></tr>
<tr class="memdesc:a33509e7a55b46fe677e682d01f8fbd87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize the <a class="el" href="a00010.html">BayesTree</a>, starting from the root.  <a href="#a33509e7a55b46fe677e682d01f8fbd87">More...</a><br/></td></tr>
<tr class="separator:a33509e7a55b46fe677e682d01f8fbd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11ffb44abea89e42c6de7a9f2f97221"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad11ffb44abea89e42c6de7a9f2f97221"></a>
template&lt;class CLIQUE &gt; </td></tr>
<tr class="memitem:ad11ffb44abea89e42c6de7a9f2f97221"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>optimizeWildfireNonRecursive</b> (const boost::shared_ptr&lt; CLIQUE &gt; &amp;root, double threshold, const <a class="el" href="a00089.html">FastSet</a>&lt; <a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> &gt; &amp;keys, <a class="el" href="a00252.html">VectorValues</a> &amp;<a class="el" href="a00290.html#ac2a0ba4a7a13e0f4c781fa9de3e5689e">delta</a>)</td></tr>
<tr class="separator:ad11ffb44abea89e42c6de7a9f2f97221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710993cf2d56652448517817943ad10f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a710993cf2d56652448517817943ad10f"></a>
template&lt;class CLIQUE &gt; </td></tr>
<tr class="memitem:a710993cf2d56652448517817943ad10f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>nnz_internal</b> (const boost::shared_ptr&lt; CLIQUE &gt; &amp;clique, int &amp;result)</td></tr>
<tr class="separator:a710993cf2d56652448517817943ad10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca63ccfbd14352eade58fd2a2ec6b5e4"><td class="memTemplParams" colspan="2"><a class="anchor" id="aca63ccfbd14352eade58fd2a2ec6b5e4"></a>
template&lt;class CLIQUE &gt; </td></tr>
<tr class="memitem:aca63ccfbd14352eade58fd2a2ec6b5e4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#aca63ccfbd14352eade58fd2a2ec6b5e4">calculate_nnz</a> (const boost::shared_ptr&lt; CLIQUE &gt; &amp;clique)</td></tr>
<tr class="memdesc:aca63ccfbd14352eade58fd2a2ec6b5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the number of non-zero entries for the tree starting at clique (use root for complete matrix) <br/></td></tr>
<tr class="separator:aca63ccfbd14352eade58fd2a2ec6b5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5860dd5dff1a6c4473014f9af98514c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5860dd5dff1a6c4473014f9af98514c"></a>
<a class="el" href="a00252.html">VectorValues</a>&#160;</td><td class="memItemRight" valign="bottom"><b>gradientInPlace</b> (const <a class="el" href="a00173.html">NonlinearFactorGraph</a> &amp;nfg, const <a class="el" href="a00244.html">Values</a> &amp;values)</td></tr>
<tr class="separator:ae5860dd5dff1a6c4473014f9af98514c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ceb9e5a5e864b96c529db67f55a873b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0ceb9e5a5e864b96c529db67f55a873b"></a>
template&lt;class S , class V , class W &gt; </td></tr>
<tr class="memitem:a0ceb9e5a5e864b96c529db67f55a873b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a0ceb9e5a5e864b96c529db67f55a873b">lineSearch</a> (const S &amp;system, const V currentValues, const W &amp;gradient)</td></tr>
<tr class="memdesc:a0ceb9e5a5e864b96c529db67f55a873b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the golden-section line search algorithm. <br/></td></tr>
<tr class="separator:a0ceb9e5a5e864b96c529db67f55a873b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab113d562c7adc22b450c056b8155f3c"><td class="memTemplParams" colspan="2">template&lt;class S , class V &gt; </td></tr>
<tr class="memitem:aab113d562c7adc22b450c056b8155f3c"><td class="memTemplItemLeft" align="right" valign="top">boost::tuple&lt; V, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#aab113d562c7adc22b450c056b8155f3c">nonlinearConjugateGradient</a> (const S &amp;system, const V &amp;initial, const <a class="el" href="a00176.html">NonlinearOptimizerParams</a> &amp;params, const bool singleIteration, const bool gradientDescent=false)</td></tr>
<tr class="memdesc:aab113d562c7adc22b450c056b8155f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement the nonlinear conjugate gradient method using the Polak-Ribieve formula suggested in <a href="http://en.wikipedia.org/wiki/Nonlinear_conjugate_gradient_method">http://en.wikipedia.org/wiki/Nonlinear_conjugate_gradient_method</a>.  <a href="#aab113d562c7adc22b450c056b8155f3c">More...</a><br/></td></tr>
<tr class="separator:aab113d562c7adc22b450c056b8155f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544e7c98a6f6224e5cbcd71f4646c52b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a544e7c98a6f6224e5cbcd71f4646c52b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a544e7c98a6f6224e5cbcd71f4646c52b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a544e7c98a6f6224e5cbcd71f4646c52b">compare</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a544e7c98a6f6224e5cbcd71f4646c52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template default compare function that assumes a testable T. <br/></td></tr>
<tr class="separator:a544e7c98a6f6224e5cbcd71f4646c52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3382482454c164c6f5817dcbe6f932b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3382482454c164c6f5817dcbe6f932b3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a3382482454c164c6f5817dcbe6f932b3">checkConvergence</a> (double relativeErrorTreshold, double absoluteErrorTreshold, double errorThreshold, double currentError, double newError, <a class="el" href="a00176.html#a2b085d375ec6effa42e3deaaeab98694">NonlinearOptimizerParams::Verbosity</a> verbosity=NonlinearOptimizerParams::SILENT)</td></tr>
<tr class="memdesc:a3382482454c164c6f5817dcbe6f932b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the relative error decrease is less than relativeErrorTreshold, the absolute error decrease is less than absoluteErrorTreshold, <em>or</em> the error itself is less than errorThreshold. <br/></td></tr>
<tr class="separator:a3382482454c164c6f5817dcbe6f932b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef971b2c69845e4fcce707306703c7b8"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#aef971b2c69845e4fcce707306703c7b8">findExampleDataFile</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aef971b2c69845e4fcce707306703c7b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the full path to an example dataset distributed with gtsam.  <a href="#aef971b2c69845e4fcce707306703c7b8">More...</a><br/></td></tr>
<tr class="separator:aef971b2c69845e4fcce707306703c7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe09e573771fd72b08069353d537725"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbe09e573771fd72b08069353d537725"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#adbe09e573771fd72b08069353d537725">createRewrittenFileName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:adbe09e573771fd72b08069353d537725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a temporary file name that needs to be ignored in .gitingnore for checking read-write oprations. <br/></td></tr>
<tr class="separator:adbe09e573771fd72b08069353d537725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b8e238c614213004cf9edb7f95730f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a03b8e238c614213004cf9edb7f95730f"></a>
<a class="el" href="a00290.html#a62b6d8d9df4bb6e0add77af1ffd41c04">GraphAndValues</a>&#160;</td><td class="memItemRight" valign="bottom"><b>load2D</b> (pair&lt; string, <a class="el" href="a00290.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a> &gt; dataset, int maxID, bool addNoise, bool smart, <a class="el" href="a00290.html#a90552b70a2da9c74595cae4b05c2ce18">NoiseFormat</a> noiseFormat, <a class="el" href="a00290.html#a8be373f34edc0a9d28b1bfab5dd62ba0">KernelFunctionType</a> kernelFunctionType)</td></tr>
<tr class="separator:a03b8e238c614213004cf9edb7f95730f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad35242897c20919be8784169179b90ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00290.html#a62b6d8d9df4bb6e0add77af1ffd41c04">GraphAndValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ad35242897c20919be8784169179b90ba">load2D</a> (const std::string &amp;filename, <a class="el" href="a00290.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a> model=<a class="el" href="a00290.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a>(), int maxID=0, bool addNoise=false, bool smart=true, <a class="el" href="a00290.html#a90552b70a2da9c74595cae4b05c2ce18">NoiseFormat</a> noiseFormat=<a class="el" href="a00290.html#a90552b70a2da9c74595cae4b05c2ce18a1f8edeb25c58a249789556c686265a4c">NoiseFormatGRAPH</a>,<a class="el" href="a00290.html#a8be373f34edc0a9d28b1bfab5dd62ba0">KernelFunctionType</a> kernelFunctionType=KernelFunctionTypeNONE)</td></tr>
<tr class="memdesc:ad35242897c20919be8784169179b90ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load TORO/G2O style graph files.  <a href="#ad35242897c20919be8784169179b90ba">More...</a><br/></td></tr>
<tr class="separator:ad35242897c20919be8784169179b90ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddc8a142b6518bb66870e893dfe8f20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00290.html#a62b6d8d9df4bb6e0add77af1ffd41c04">GraphAndValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#aaddc8a142b6518bb66870e893dfe8f20">load2D_robust</a> (const string &amp;filename, noiseModel::Base::shared_ptr &amp;model, int maxID)</td></tr>
<tr class="separator:aaddc8a142b6518bb66870e893dfe8f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe516bc2d9ca4cc4530dd3b8460ce3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acfe516bc2d9ca4cc4530dd3b8460ce3d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#acfe516bc2d9ca4cc4530dd3b8460ce3d">save2D</a> (const <a class="el" href="a00173.html">NonlinearFactorGraph</a> &amp;graph, const <a class="el" href="a00244.html">Values</a> &amp;config, const noiseModel::Diagonal::shared_ptr model, const std::string &amp;filename)</td></tr>
<tr class="memdesc:acfe516bc2d9ca4cc4530dd3b8460ce3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">save 2d graph <br/></td></tr>
<tr class="separator:acfe516bc2d9ca4cc4530dd3b8460ce3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8caf13571ec334f8d789f4acc8e2ace5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00290.html#a62b6d8d9df4bb6e0add77af1ffd41c04">GraphAndValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a8caf13571ec334f8d789f4acc8e2ace5">readG2o</a> (const std::string &amp;g2oFile, <a class="el" href="a00290.html#a8be373f34edc0a9d28b1bfab5dd62ba0">KernelFunctionType</a> kernelFunctionType=KernelFunctionTypeNONE)</td></tr>
<tr class="memdesc:a8caf13571ec334f8d789f4acc8e2ace5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses a g2o file and stores the measurements into a <a class="el" href="a00173.html" title="A non-linear factor graph is a graph of non-Gaussian, i.e.">NonlinearFactorGraph</a> and the initial guess in a <a class="el" href="a00244.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a> structure.  <a href="#a8caf13571ec334f8d789f4acc8e2ace5">More...</a><br/></td></tr>
<tr class="separator:a8caf13571ec334f8d789f4acc8e2ace5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bc584d72da3747666ac134a9490f92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a68bc584d72da3747666ac134a9490f92">writeG2o</a> (const <a class="el" href="a00173.html">NonlinearFactorGraph</a> &amp;graph, const <a class="el" href="a00244.html">Values</a> &amp;estimate, const std::string &amp;filename)</td></tr>
<tr class="memdesc:a68bc584d72da3747666ac134a9490f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes a g2o file from <a class="el" href="a00173.html" title="A non-linear factor graph is a graph of non-Gaussian, i.e.">NonlinearFactorGraph</a> and a <a class="el" href="a00244.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a> structure.  <a href="#a68bc584d72da3747666ac134a9490f92">More...</a><br/></td></tr>
<tr class="separator:a68bc584d72da3747666ac134a9490f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91606476a4bb8cf6b890546cae31a612"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91606476a4bb8cf6b890546cae31a612"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a91606476a4bb8cf6b890546cae31a612">load3D</a> (const std::string &amp;filename)</td></tr>
<tr class="memdesc:a91606476a4bb8cf6b890546cae31a612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load TORO 3D Graph. <br/></td></tr>
<tr class="separator:a91606476a4bb8cf6b890546cae31a612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7ce86bab3b1d18e912c7c61e0c8f02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e7ce86bab3b1d18e912c7c61e0c8f02"></a>
<a class="el" href="a00205.html">Rot3</a>&#160;</td><td class="memItemRight" valign="bottom"><b>openGLFixedRotation</b> ()</td></tr>
<tr class="separator:a6e7ce86bab3b1d18e912c7c61e0c8f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6eca65dc0168a65f641961ca97924c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00189.html">Pose3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ade6eca65dc0168a65f641961ca97924c">openGL2gtsam</a> (const <a class="el" href="a00205.html">Rot3</a> &amp;R, double tx, double ty, double tz)</td></tr>
<tr class="memdesc:ade6eca65dc0168a65f641961ca97924c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts an openGL camera pose to an GTSAM camera pose.  <a href="#ade6eca65dc0168a65f641961ca97924c">More...</a><br/></td></tr>
<tr class="separator:ade6eca65dc0168a65f641961ca97924c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff07ef70e6161c4d1d2bd7546ff91e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00189.html">Pose3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#aaff07ef70e6161c4d1d2bd7546ff91e6">gtsam2openGL</a> (const <a class="el" href="a00205.html">Rot3</a> &amp;R, double tx, double ty, double tz)</td></tr>
<tr class="memdesc:aaff07ef70e6161c4d1d2bd7546ff91e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts a GTSAM camera pose to an openGL camera pose.  <a href="#aaff07ef70e6161c4d1d2bd7546ff91e6">More...</a><br/></td></tr>
<tr class="separator:aaff07ef70e6161c4d1d2bd7546ff91e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad632ed56581bf174eef379bbe272a06a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00189.html">Pose3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ad632ed56581bf174eef379bbe272a06a">gtsam2openGL</a> (const <a class="el" href="a00189.html">Pose3</a> &amp;PoseGTSAM)</td></tr>
<tr class="memdesc:ad632ed56581bf174eef379bbe272a06a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts a GTSAM camera pose to an openGL camera pose.  <a href="#ad632ed56581bf174eef379bbe272a06a">More...</a><br/></td></tr>
<tr class="separator:ad632ed56581bf174eef379bbe272a06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef96840653460872d4e7a74349f77c42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#aef96840653460872d4e7a74349f77c42">readBundler</a> (const std::string &amp;filename, <a class="el" href="a00212.html">SfM_data</a> &amp;data)</td></tr>
<tr class="memdesc:aef96840653460872d4e7a74349f77c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses a bundler output file and stores the data into a <a class="el" href="a00212.html" title="Define the structure for SfM data.">SfM_data</a> structure.  <a href="#aef96840653460872d4e7a74349f77c42">More...</a><br/></td></tr>
<tr class="separator:aef96840653460872d4e7a74349f77c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b97b60419b8535ccdaa385ce6d7cc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a07b97b60419b8535ccdaa385ce6d7cc6">readBAL</a> (const std::string &amp;filename, <a class="el" href="a00212.html">SfM_data</a> &amp;data)</td></tr>
<tr class="memdesc:a07b97b60419b8535ccdaa385ce6d7cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses a "Bundle Adjustment in the Large" (BAL) file and stores the data into a <a class="el" href="a00212.html" title="Define the structure for SfM data.">SfM_data</a> structure.  <a href="#a07b97b60419b8535ccdaa385ce6d7cc6">More...</a><br/></td></tr>
<tr class="separator:a07b97b60419b8535ccdaa385ce6d7cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbdf1d3cfef0058a15eca02d31037e9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#acbdf1d3cfef0058a15eca02d31037e9b">writeBAL</a> (const std::string &amp;filename, <a class="el" href="a00212.html">SfM_data</a> &amp;data)</td></tr>
<tr class="memdesc:acbdf1d3cfef0058a15eca02d31037e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes a "Bundle Adjustment in the Large" (BAL) file from a <a class="el" href="a00212.html" title="Define the structure for SfM data.">SfM_data</a> structure.  <a href="#acbdf1d3cfef0058a15eca02d31037e9b">More...</a><br/></td></tr>
<tr class="separator:acbdf1d3cfef0058a15eca02d31037e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d34be139e927fde97f85d83144c02a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a28d34be139e927fde97f85d83144c02a">writeBALfromValues</a> (const std::string &amp;filename, const <a class="el" href="a00212.html">SfM_data</a> &amp;data, <a class="el" href="a00244.html">Values</a> &amp;values)</td></tr>
<tr class="memdesc:a28d34be139e927fde97f85d83144c02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function writes a "Bundle Adjustment in the Large" (BAL) file from a <a class="el" href="a00212.html" title="Define the structure for SfM data.">SfM_data</a> structure and a value structure (measurements are the same as the SfM input data, while camera poses and values are read from <a class="el" href="a00244.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a>)  <a href="#a28d34be139e927fde97f85d83144c02a">More...</a><br/></td></tr>
<tr class="separator:a28d34be139e927fde97f85d83144c02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07fada7b5119506b7f30d5ddbd1b53f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00244.html">Values</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a07fada7b5119506b7f30d5ddbd1b53f7">initialCamerasEstimate</a> (const <a class="el" href="a00212.html">SfM_data</a> &amp;db)</td></tr>
<tr class="memdesc:a07fada7b5119506b7f30d5ddbd1b53f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates initial values for cameras from db.  <a href="#a07fada7b5119506b7f30d5ddbd1b53f7">More...</a><br/></td></tr>
<tr class="separator:a07fada7b5119506b7f30d5ddbd1b53f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdef8c3f883714f9937097e500f3eb1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00244.html">Values</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#abdef8c3f883714f9937097e500f3eb1d">initialCamerasAndPointsEstimate</a> (const <a class="el" href="a00212.html">SfM_data</a> &amp;db)</td></tr>
<tr class="memdesc:abdef8c3f883714f9937097e500f3eb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates initial values for cameras and points from db.  <a href="#abdef8c3f883714f9937097e500f3eb1d">More...</a><br/></td></tr>
<tr class="separator:abdef8c3f883714f9937097e500f3eb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0785ab0356df59265448737d25ee937f"><td class="memItemLeft" align="right" valign="top">GTSAM_EXPORT <a class="el" href="a00290.html#a62b6d8d9df4bb6e0add77af1ffd41c04">GraphAndValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#a0785ab0356df59265448737d25ee937f">load2D</a> (std::pair&lt; std::string, <a class="el" href="a00290.html#ab6e5a4884342656e0837ef07008ec03f">SharedNoiseModel</a> &gt; dataset, int maxID=0, bool addNoise=false, bool smart=true, <a class="el" href="a00290.html#a90552b70a2da9c74595cae4b05c2ce18">NoiseFormat</a> noiseFormat=<a class="el" href="a00290.html#a90552b70a2da9c74595cae4b05c2ce18a1f8edeb25c58a249789556c686265a4c">NoiseFormatGRAPH</a>, <a class="el" href="a00290.html#a8be373f34edc0a9d28b1bfab5dd62ba0">KernelFunctionType</a> kernelFunctionType=KernelFunctionTypeNONE)</td></tr>
<tr class="memdesc:a0785ab0356df59265448737d25ee937f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load TORO 2D Graph.  <a href="#a0785ab0356df59265448737d25ee937f">More...</a><br/></td></tr>
<tr class="separator:a0785ab0356df59265448737d25ee937f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d640f59e5d39a1165069a3841cc5d1"><td class="memTemplParams" colspan="2">template&lt;class T , class P &gt; </td></tr>
<tr class="memitem:a80d640f59e5d39a1165069a3841cc5d1"><td class="memTemplItemLeft" align="right" valign="top">P&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00290.html#a80d640f59e5d39a1165069a3841cc5d1">transform_point</a> (const T &amp;<a class="el" href="a00290.html#aa2e36d7ab63000feddaeb61bbfcf2db1">trans</a>, const P &amp;global, boost::optional&lt; Matrix &amp; &gt; Dtrans, boost::optional&lt; Matrix &amp; &gt; Dglobal)</td></tr>
<tr class="memdesc:a80d640f59e5d39a1165069a3841cc5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform function that must be specialized specific domains.  <a href="#a80d640f59e5d39a1165069a3841cc5d1">More...</a><br/></td></tr>
<tr class="separator:a80d640f59e5d39a1165069a3841cc5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab8b4f36c2129e113c3652c32d611fecb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8b4f36c2129e113c3652c32d611fecb"></a>
GTSAM_EXPORT <a class="el" href="a00088.html">FastMap</a><br class="typebreak"/>
&lt; std::string, <br class="typebreak"/>
<a class="el" href="a00248.html">ValueWithDefault</a>&lt; bool, false &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>debugFlags</b></td></tr>
<tr class="separator:ab8b4f36c2129e113c3652c32d611fecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5602eb85d05df6cba60e47eebbd3636"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad5602eb85d05df6cba60e47eebbd3636"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00290.html#ad5602eb85d05df6cba60e47eebbd3636">logSqrt2PI</a> = log(std::sqrt(2.0 * M_PI))</td></tr>
<tr class="memdesc:ad5602eb85d05df6cba60e47eebbd3636"><td class="mdescLeft">&#160;</td><td class="mdescRight">constant needed below <br/></td></tr>
<tr class="separator:ad5602eb85d05df6cba60e47eebbd3636"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Global functions in a separate testing namespace. </p>
<p>testTriangulationFactor.h</p>
<p>Matrix is a typedef in the gtsam namespace TODO: make a version to work with matlab wrapping we use the default &lt; double,col_major,unbounded_array&lt;double&gt; &gt;</p>
<p>These should not be used outside of tests, as they are just remappings of the original functions. We use these to avoid needing to do too much boost::bind magic or writing a bunch of separate proxy functions.</p>
<p>Don't expect all classes to work for all of these functions.</p>
<dl class="section date"><dt>Date</dt><dd>March 2, 2014 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Frank Dellaert </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a59e2c1120d40da6062c03ab31e869065"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Eigen::Quaternion&lt;double, Eigen::DontAlign&gt; <a class="el" href="a00290.html#a59e2c1120d40da6062c03ab31e869065">gtsam::Quaternion</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef to an Eigen Quaternion&lt;double&gt;, we disable alignment because geometry objects are stored in boost pool allocators, in <a class="el" href="a00244.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a> containers, and and these pool allocators do not support alignment. </p>

</div>
</div>
<a class="anchor" id="ab6e5a4884342656e0837ef07008ec03f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef noiseModel::Base::shared_ptr <a class="el" href="a00290.html#ab6e5a4884342656e0837ef07008ec03f">gtsam::SharedNoiseModel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Note, deliberately not in <a class="el" href="a00546.html" title="All noise models live in the noiseModel namespace.">noiseModel</a> namespace. </p>
<p>Deprecated. Only for compatibility with previous version. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a90552b70a2da9c74595cae4b05c2ce18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00290.html#a90552b70a2da9c74595cae4b05c2ce18">gtsam::NoiseFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates how noise parameters are stored in file. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a90552b70a2da9c74595cae4b05c2ce18ad0aaa5c51a45cb7c9151aae60a603209"></a>NoiseFormatG2O</em>&nbsp;</td><td class="fielddoc">
<p>Information matrix I11, I12, I13, I22, I23, I33. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a90552b70a2da9c74595cae4b05c2ce18a3790bc2c6f11cd7da84730b33173de5a"></a>NoiseFormatTORO</em>&nbsp;</td><td class="fielddoc">
<p>Information matrix, but inf_ff inf_fs inf_ss inf_rr inf_fr inf_sr. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a90552b70a2da9c74595cae4b05c2ce18a1f8edeb25c58a249789556c686265a4c"></a>NoiseFormatGRAPH</em>&nbsp;</td><td class="fielddoc">
<p>default: toro-style order, but covariance matrix ! </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a90552b70a2da9c74595cae4b05c2ce18a5450a16f3522214ccdfa23c461e7d05a"></a>NoiseFormatCOV</em>&nbsp;</td><td class="fielddoc">
<p>Covariance matrix C11, C12, C13, C22, C23, C33. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a5ba06101b45d9f2647608cbf4e3b35aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::abs </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Absolute values of vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>is a vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>[abs(a(i))] </dd></dl>

</div>
</div>
<a class="anchor" id="add6d6575582314cc9b5dbdbe2a86374d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gtsam::assert_equal </td>
          <td>(</td>
          <td class="paramtype">const boost::optional&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::optional&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparisons for boost.optional objects that checks whether objects exist before comparing their values. </p>
<p>First version allows for both to be boost::none, but the second, with expected given rather than optional</p>
<p>Concept requirement: V is testable </p>

</div>
</div>
<a class="anchor" id="a0931276a9406dfc1bcff6d265704ee39"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool gtsam::assert_equal </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>expected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; V &gt; &amp;&#160;</td>
          <td class="paramname"><em>actual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Version of assert_equals to work with vectors. </p>
<dl class="deprecated"><dt><b><a class="el" href="a00563.html#_deprecated000003">Deprecated:</a></b></dt><dd>: use container equals instead </dd></dl>

</div>
</div>
<a class="anchor" id="a9f3ee662d25ffb8c04b4e35c4b02e90b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::assert_equal </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same, prints if error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>Vector </td></tr>
    <tr><td class="paramname">vec2</td><td>Vector </td></tr>
    <tr><td class="paramname">tol</td><td>1e-9 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a class="anchor" id="ac3cf8e8e70cd696d9c789c31bc1e89a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::assert_equal </td>
          <td>(</td>
          <td class="paramtype">const SubVector &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SubVector &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same, prints if error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>Vector </td></tr>
    <tr><td class="paramname">vec2</td><td>Vector </td></tr>
    <tr><td class="paramname">tol</td><td>1e-9 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a class="anchor" id="a2ca3db47b15350977c1f03c5560ab332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::assert_inequal </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not the same, prints if error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>Vector </td></tr>
    <tr><td class="paramname">vec2</td><td>Vector </td></tr>
    <tr><td class="paramname">tol</td><td>1e-9 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a class="anchor" id="a30a89a0147943428129e2cb3683988be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class V1 , class V2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gtsam::axpy </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>BLAS Level 1 axpy: y &lt;- alpha*x + y. </p>
<dl class="deprecated"><dt><b><a class="el" href="a00563.html#_deprecated000005">Deprecated:</a></b></dt><dd>: use operators instead </dd></dl>

</div>
</div>
<a class="anchor" id="a0d998e1b770c9864946ddb031b1c4522"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::backSubstituteLower </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unit</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>backSubstitute L*x=b </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">L</td><td>an lower triangular matrix </td></tr>
    <tr><td class="paramname">b</td><td>an RHS vector </td></tr>
    <tr><td class="paramname">unit,set</td><td>true if unit triangular </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the solution x of L*x=b </dd></dl>

</div>
</div>
<a class="anchor" id="a6c4876cbe85d5651a52eda0e97c60f2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::backSubstituteUpper </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unit</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>backSubstitute U*x=b </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>an upper triangular matrix </td></tr>
    <tr><td class="paramname">b</td><td>an RHS vector </td></tr>
    <tr><td class="paramname">unit,set</td><td>true if unit triangular </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the solution x of U*x=b </dd></dl>

</div>
</div>
<a class="anchor" id="a8b0bf332d52b333dab2b20d763c8925b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::backSubstituteUpper </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unit</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>backSubstitute x'*U=b' </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>an upper triangular matrix </td></tr>
    <tr><td class="paramname">b</td><td>an RHS vector </td></tr>
    <tr><td class="paramname">unit,set</td><td>true if unit triangular </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the solution x of x'*U=b' </dd></dl>

</div>
</div>
<a class="anchor" id="a6ec32e8dafe1d25ab11de3d693c1b5a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector gtsam::basis </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create basis vector of dimension n, with one in spot i. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the size of the vector </td></tr>
    <tr><td class="paramname">i</td><td>index of the one </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>basis vector </dd></dl>

</div>
</div>
<a class="anchor" id="adbd55c711e6ceee791b595558eb3ec8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T gtsam::BCH </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Three term approximation of the Baker�Campbell�Hausdorff formula In non-commutative Lie groups, when composing exp(Z) = exp(X)exp(Y) it is not true that Z = X+Y. </p>
<p>Instead, Z can be calculated using the BCH formula: Z = X + Y + [X,Y]/2 + [X-Y,[X,Y]]/12 - [Y,[X,[X,Y]]]/24 <a href="http://en.wikipedia.org/wiki/Baker">http://en.wikipedia.org/wiki/Baker</a>�Campbell�Hausdorff_formulaAGC: bracket() only appears in <a class="el" href="a00205.html">Rot3</a> tests, should this be used elsewhere? </p>

</div>
</div>
<a class="anchor" id="a473aea76af7b0cbec8f26e6abf1ed87e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T gtsam::between_default </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>l2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These core global functions can be specialized by new Lie types for better performance. </p>
<p>Compute l0 s.t. l2=l1*l0 </p>

</div>
</div>
<a class="anchor" id="a35831074a7aab15d463acddc7767bfe8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="a00005.html">Assignment</a>&lt;L&gt; &gt; gtsam::cartesianProduct </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; L, size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Cartesian product consisting all possible configurations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>list of keys (label,cardinality) pairs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector list of all possible value assignments</dd></dl>
<p>This function returns a vector of <a class="el" href="a00005.html" title="An assignment from labels to value index (size_t).">Assignment</a> values for all possible (Cartesian product) configurations of set of Keys which are nothing but (Label,cardinality) pairs. This function should NOT be called for more than a small number of variables and cardinalities. E.g. For 6 variables with each having cardinalities 4, we get 4096 possible configurations!! </p>

</div>
</div>
<a class="anchor" id="aba542e2cd85f08b76f80a0871a4ea713"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Matrix gtsam::cholesky_inverse </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the inverse of a S.P.D. </p>
<p>matrix. Inversion is done via Cholesky decomposition. </p>

</div>
</div>
<a class="anchor" id="a747683f736c50bca16b3aab0e95b1b76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::pair&lt; size_t, bool &gt; gtsam::choleskyCareful </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>ATA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Careful" Cholesky computes the positive square-root of a positive symmetric semi-definite matrix (i.e. </p>
<p>that may be rank-deficient). Unlike standard Cholesky, the square-root factor may have all-zero rows for free variables.</p>
<p>Additionally, this function returns the index of the row after the last non-zero row in the computed factor, so that it may be truncated to an upper-trapazoidal matrix.</p>
<p>The second element of the return value is <code>true</code> if the matrix was factored successfully, or <code>false</code> if it was non-positive-semidefinite (i.e. indefinite or negative-(semi-)definite.</p>
<p>Note that this returned index is the rank of the matrix if and only if all of the zero-rows of the factor occur after any non-zero rows. This is (always?) the case during elimination of a fully-constrained least-squares problem.</p>
<p>The optional order argument specifies the size of the square upper-left submatrix to operate on, ignoring the rest of the matrix. </p>

</div>
</div>
<a class="anchor" id="a1eb8c69f6e0b90ac2dec4287ee8fcb0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::choleskyPartial </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>ABC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nFrontal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partial Cholesky computes a factor [R S such that [R' 0 [R S = [A B 0 L] S' I] 0 L] B' C]. </p>
<p>The input to this function is the matrix ABC = [A B], and the parameter [B' C] nFrontal determines the split between A, B, and C, with A being of size nFrontal x nFrontal.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the decomposition is successful, <code>false</code> if <code>A</code> was not positive-definite. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8b524ba6c9aed0d21a020999c9b5d88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Matrix gtsam::collect </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const Matrix * &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a matrix by concatenating Given a set of matrices: A1, A2, A3... </p>
<p>If all matrices have the same size, specifying single matrix dimensions will avoid the lookup of dimensions </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrices</td><td>is a vector of matrices in the order to be collected </td></tr>
    <tr><td class="paramname">m</td><td>is the number of rows of a single matrix </td></tr>
    <tr><td class="paramname">n</td><td>is the number of columns of a single matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>combined matrix [A1 A2 A3] </dd></dl>

</div>
</div>
<a class="anchor" id="a559dba69e2854eb66e34222f60f55722"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MATRIX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const MATRIX::ConstColXpr gtsam::column </td>
          <td>(</td>
          <td class="paramtype">const MATRIX &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a column view from a matrix that avoids a copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix to extract column from </td></tr>
    <tr><td class="paramname">j</td><td>index of the column </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const view of the matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a6516ea957c3a22ddf429cefef1fe9486"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S , class V , class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">V gtsam::conjugateGradients </td>
          <td>(</td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>Ab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConjugateGradientParameters &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>steepest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method of conjugate gradients (CG) template "System" class S needs gradient(S,v), e=S*v, v=S^e "Vector" class V needs dot(v,v), -v, v+v, s*v "Vector" class E needs dot(v,v) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ab,the</td><td>"system" that needs to be solved, examples below </td></tr>
    <tr><td class="paramname">x</td><td>is the initial estimate </td></tr>
    <tr><td class="paramname">steepest</td><td>flag, if true does steepest descent, not CG </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2a0ba4a7a13e0f4c781fa9de3e5689e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::delta </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create basis vector of dimension n, with a constant in spot i. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the size of the vector </td></tr>
    <tr><td class="paramname">i</td><td>index of the one </td></tr>
    <tr><td class="paramname">value</td><td>is the value to insert into the vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>delta vector </dd></dl>

</div>
</div>
<a class="anchor" id="ab2c65f1a69009a306b6a5f9ef31dcee2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT boost::tuple&lt; int, double, Vector &gt; gtsam::DLT </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rank_tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direct linear transform algorithm that calls svd to find a vector v that minimizes the algebraic error A*v. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>of size m*n, where m&gt;=n (pad with zero rows if not!) Returns rank of A, minimum error (singular value), and corresponding eigenvector (column of V, with A=U*S*V') </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0d4fbafe5819f4617da45c107b3e616"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::ediv </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise division </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first vector </td></tr>
    <tr><td class="paramname">b</td><td>second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector [a(i)/b(i)] </dd></dl>

</div>
</div>
<a class="anchor" id="a14844c96706dc362917e0d5e76d65fbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::ediv_ </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise division, but 0/0 = 0, not inf </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first vector </td></tr>
    <tr><td class="paramname">b</td><td>second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector [a(i)/b(i)] </dd></dl>

</div>
</div>
<a class="anchor" id="ab08665ce2fa3fdc3f7ff6d87b26452cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::emul </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>elementwise multiplication </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first vector </td></tr>
    <tr><td class="paramname">b</td><td>second vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector [a(i)*b(i)] </dd></dl>

</div>
</div>
<a class="anchor" id="a6c974066d393d86d744e9d387f0d3f50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::esqrt </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elementwise sqrt of vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>is a vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>[sqrt(a(i))] </dd></dl>

</div>
</div>
<a class="anchor" id="a3041816208c79ef76d3ef2e0991d90b2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T gtsam::expm </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>K</em> = <code>7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exponential map given exponential coordinates class T needs a wedge&lt;&gt; function and a constructor from Matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>exponential coordinates, vector of size n @ return a T </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab15462d8c16813d0a7a5b1f76a2f64b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Matrix gtsam::expm </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>K</em> = <code>7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Numerical exponential map, naive approach, not industrial strength !!! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix to exponentiate </td></tr>
    <tr><td class="paramname">K</td><td>number of iterations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0170df6a1f64df845e4445bdf777742"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T gtsam::expmap_default </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exponential map centered at l0, s.t. </p>
<p>exp(t,d) = t*exp(d) </p>

</div>
</div>
<a class="anchor" id="a728f2e626412c19fa789a65eaba41819"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Matrix gtsam::eye </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an identity matrix, with matlab-like syntax. </p>
<p>Note: if assigning a block (created from an Eigen block() function) of a matrix to identity, don't use this function, instead use ".setIdentity(m,n)" to avoid an Eigen error. </p>

</div>
</div>
<a class="anchor" id="ae683ac9fd3c4679ddde00872d37f0975"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix gtsam::eye </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a square identity matrix, with matlab-like syntax. </p>
<p>Note: if assigning a block (created from an Eigen block() function) of a matrix to identity, don't use this function, instead use ".setIdentity(m)" to avoid an Eigen error. </p>

</div>
</div>
<a class="anchor" id="aef971b2c69845e4fcce707306703c7b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::string gtsam::findExampleDataFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the full path to an example dataset distributed with gtsam. </p>
<p>The name may be specified with or without a file extension - if no extension is given, this function first looks for the .graph extension, then .txt. We first check the gtsam source tree for the file, followed by the installed example dataset location. Both the source tree and installed locations are obtained from CMake during compilation. </p>
<dl class="section return"><dt>Returns</dt><dd>The full path and filename to the requested dataset. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if no matching file could be found using the search process described above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaff07ef70e6161c4d1d2bd7546ff91e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a00189.html">Pose3</a> gtsam::gtsam2openGL </td>
          <td>(</td>
          <td class="paramtype">const Rot3 &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts a GTSAM camera pose to an openGL camera pose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>rotation in GTSAM </td></tr>
    <tr><td class="paramname">tx</td><td>x component of the translation in GTSAM </td></tr>
    <tr><td class="paramname">ty</td><td>y component of the translation in GTSAM </td></tr>
    <tr><td class="paramname">tz</td><td>z component of the translation in GTSAM </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00189.html">Pose3</a> in openGL format </dd></dl>

</div>
</div>
<a class="anchor" id="ad632ed56581bf174eef379bbe272a06a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a00189.html">Pose3</a> gtsam::gtsam2openGL </td>
          <td>(</td>
          <td class="paramtype">const Pose3 &amp;&#160;</td>
          <td class="paramname"><em>PoseGTSAM</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts a GTSAM camera pose to an openGL camera pose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PoseGTSAM</td><td>pose in GTSAM format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00189.html">Pose3</a> in openGL format </dd></dl>

</div>
</div>
<a class="anchor" id="a35c269c3243cab16a7475239a9c91021"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::hasConstraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00103.html">GaussianFactorGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates whether linear factors have any constrained noise models. </p>
<dl class="section return"><dt>Returns</dt><dd>true if any factor is constrained. </dd></dl>

</div>
</div>
<a class="anchor" id="afb77eefc25dea0fb3e0fcc8f246b617a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::pair&lt; double, Vector &gt; gtsam::house </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>house(x,j) computes HouseHolder vector v and scaling factor beta from x, such that the corresponding Householder reflection zeroes out all but x. </p>
<p>(j), j is base 0. Golub &amp; Van Loan p 210. </p>

</div>
</div>
<a class="anchor" id="a7baa2f3184a444adce108633c0265e0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::householder </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Householder tranformation, zeros below diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>number of columns to zero out below diagonal </td></tr>
    <tr><td class="paramname">A</td><td>matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing: in place !!! </dd></dl>

</div>
</div>
<a class="anchor" id="abdd1ab05e8ac90b340fbd8f3b322dc6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::householder_ </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_vectors</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imperative version of Householder QR factorization, Golub &amp; Van Loan p 224 version with Householder vectors below diagonal, as in GVL. </p>
<p>Householder transformation, Householder vectors below diagonal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>number of columns to zero out below diagonal </td></tr>
    <tr><td class="paramname">A</td><td>matrix </td></tr>
    <tr><td class="paramname">copy_vectors</td><td>- true to copy Householder vectors below diagonal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing: in place !!! </dd></dl>

</div>
</div>
<a class="anchor" id="abdef8c3f883714f9937097e500f3eb1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a00244.html">Values</a> gtsam::initialCamerasAndPointsEstimate </td>
          <td>(</td>
          <td class="paramtype">const SfM_data &amp;&#160;</td>
          <td class="paramname"><em>db</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates initial values for cameras and points from db. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="a00212.html" title="Define the structure for SfM data.">SfM_data</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00244.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a07fada7b5119506b7f30d5ddbd1b53f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a00244.html">Values</a> gtsam::initialCamerasEstimate </td>
          <td>(</td>
          <td class="paramtype">const SfM_data &amp;&#160;</td>
          <td class="paramname"><em>db</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates initial values for cameras from db. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="a00212.html" title="Define the structure for SfM data.">SfM_data</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00244.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1dc9a38f15c24872e82b504fa9761340"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MATRIX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtsam::inplace_QR </td>
          <td>(</td>
          <td class="paramtype">MATRIX &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>QR factorization using Eigen's internal block QR algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>is the input matrix, and is the output </td></tr>
    <tr><td class="paramname">clear_below_diagonal</td><td>enables zeroing out below diagonal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab8583da4b37aefb1697375402a265c9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::insertColumn </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inserts a column into a matrix IN PLACE NOTE: there is no size checking Alternate form allows for vectors smaller than the whole column to be inserted </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix to be modified in place </td></tr>
    <tr><td class="paramname">col</td><td>is the vector to be inserted </td></tr>
    <tr><td class="paramname">j</td><td>is the index to insert the column </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b42c1bd6a8d1152ee1ef86b96526993"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::insertSub </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>fullMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>subMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>insert a submatrix IN PLACE at a specified location in a larger matrix NOTE: there is no size checking </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fullMatrix</td><td>matrix to be updated </td></tr>
    <tr><td class="paramname">subMatrix</td><td>matrix to be inserted </td></tr>
    <tr><td class="paramname">i</td><td>is the row of the upper left corner insert location </td></tr>
    <tr><td class="paramname">j</td><td>is the column of the upper left corner insert location </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a0cfd7908b06491df49b6a9c9186775"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::linear_dependent </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>vec2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check whether two vectors are linearly dependent </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec1</td><td>Vector </td></tr>
    <tr><td class="paramname">vec2</td><td>Vector </td></tr>
    <tr><td class="paramname">tol</td><td>1e-9 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool </dd></dl>

</div>
</div>
<a class="anchor" id="ac3ed0dcde6a0084d7f1792c396e5dbaf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00154.html">ListOfOneContainer</a>&lt;T&gt; gtsam::ListOfOne </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factory function for <a class="el" href="a00154.html" title="A helper class that behaves as a container with one element, and works with boost::range.">ListOfOneContainer</a> to enable ListOfOne(e) syntax. </p>

</div>
</div>
<a class="anchor" id="a0785ab0356df59265448737d25ee937f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a00290.html#a62b6d8d9df4bb6e0add77af1ffd41c04">GraphAndValues</a> gtsam::load2D </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; std::string, SharedNoiseModel &gt;&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxID</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addNoise</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>smart</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NoiseFormat&#160;</td>
          <td class="paramname"><em>noiseFormat</em> = <code>NoiseFormatGRAPH</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KernelFunctionType&#160;</td>
          <td class="paramname"><em>kernelFunctionType</em> = <code>KernelFunctionTypeNONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load TORO 2D Graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataset/model</td><td>pair as constructed by [dataset] </td></tr>
    <tr><td class="paramname">maxID</td><td>if non-zero cut out vertices &gt;= maxID </td></tr>
    <tr><td class="paramname">addNoise</td><td>add noise to the edges </td></tr>
    <tr><td class="paramname">smart</td><td>try to reduce complexity of covariance to cheapest model </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad35242897c20919be8784169179b90ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a00290.html#a62b6d8d9df4bb6e0add77af1ffd41c04">GraphAndValues</a> gtsam::load2D </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SharedNoiseModel&#160;</td>
          <td class="paramname"><em>model</em> = <code>SharedNoiseModel()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxID</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addNoise</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>smart</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NoiseFormat&#160;</td>
          <td class="paramname"><em>noiseFormat</em> = <code>NoiseFormatGRAPH</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KernelFunctionType&#160;</td>
          <td class="paramname"><em>kernelFunctionType</em> = <code>KernelFunctionTypeNONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load TORO/G2O style graph files. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td></td></tr>
    <tr><td class="paramname">model</td><td>optional noise model to use instead of one specified by file </td></tr>
    <tr><td class="paramname">maxID</td><td>if non-zero cut out vertices &gt;= maxID </td></tr>
    <tr><td class="paramname">addNoise</td><td>add noise to the edges </td></tr>
    <tr><td class="paramname">smart</td><td>try to reduce complexity of covariance to cheapest model </td></tr>
    <tr><td class="paramname">noiseFormat</td><td>how noise parameters are stored </td></tr>
    <tr><td class="paramname">kernelFunctionType</td><td>whether to wrap the noise model in a robust kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>graph and initial values </dd></dl>

</div>
</div>
<a class="anchor" id="aaddc8a142b6518bb66870e893dfe8f20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a00290.html#a62b6d8d9df4bb6e0add77af1ffd41c04">GraphAndValues</a> gtsam::load2D_robust </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">noiseModel::Base::shared_ptr &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxID</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="a00563.html#_deprecated000014">Deprecated:</a></b></dt><dd>load2D now allows for arbitrary models and wrapping a robust kernel </dd></dl>

</div>
</div>
<a class="anchor" id="a75c80ae2fd169fcdd8708c37784a880a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector gtsam::logmap_default </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>l0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Log map centered at l0, s.t. </p>
<p>exp(l0,log(l0,lp)) = lp </p>

</div>
</div>
<a class="anchor" id="ab21cbc51fd8128a843739dbe5e0b2421"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT double gtsam::max </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the max element of a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>is a vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max(a) </dd></dl>

</div>
</div>
<a class="anchor" id="ae9a7dceb0a85c356062b55f6939b1419"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> gtsam::mrsymbol </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a symbol key from a character, label and index, i.e. </p>
<p>xA5. </p>

</div>
</div>
<a class="anchor" id="a37995b0d0610e5fb29c6bd0715151d67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char gtsam::mrsymbolChr </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the character portion of a symbol key. </p>

</div>
</div>
<a class="anchor" id="a4adc1bb606fa4a14d5dbd246f95cecd3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t gtsam::mrsymbolIndex </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the index portion of a symbol key. </p>

</div>
</div>
<a class="anchor" id="a4e4c133c4fd0d9d73593f601be2248a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char gtsam::mrsymbolLabel </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the label portion of a symbol key. </p>

</div>
</div>
<a class="anchor" id="aab113d562c7adc22b450c056b8155f3c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S , class V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::tuple&lt;V, int&gt; gtsam::nonlinearConjugateGradient </td>
          <td>(</td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NonlinearOptimizerParams &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>singleIteration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>gradientDescent</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implement the nonlinear conjugate gradient method using the Polak-Ribieve formula suggested in <a href="http://en.wikipedia.org/wiki/Nonlinear_conjugate_gradient_method">http://en.wikipedia.org/wiki/Nonlinear_conjugate_gradient_method</a>. </p>
<p>The S (system) class requires three member functions: error(state), gradient(state) and advance(state, step-size, direction). The V class denotes the state or the solution.</p>
<p>The last parameter is a switch between gradient-descent and conjugate gradient </p>

</div>
</div>
<a class="anchor" id="aaa3ddc32a5a6b8eed2d5efe69d1cb171"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT double gtsam::norm_2 </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates L2 norm for a vector modeled after boost.ublas for compatibility. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the L2 norm </dd></dl>

</div>
</div>
<a class="anchor" id="a168905f3fbaf00610d4dc486bcc4365b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix gtsam::numericalDerivative11 </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; Y(const X &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 1 of unary function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>unary function yielding m-vector </td></tr>
    <tr><td class="paramname">x</td><td>n-dimensional value at which to evaluate h </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative Class Y is the output argument Class X is the input argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing Both classes X,Y need dim, expmap, logmap </dd></dl>

</div>
</div>
<a class="anchor" id="aeaaad2ac19febd86f2afa7c6916659b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix gtsam::numericalDerivative21 </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; Y(const X1 &amp;, const X2 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 1 of binary function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>binary function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing All classes Y,X1,X2 need dim, expmap, logmap </dd></dl>

</div>
</div>
<a class="anchor" id="ad054ef564f08a62522b456cf677502a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix gtsam::numericalDerivative22 </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; Y(const X1 &amp;, const X2 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 2 of binary function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>binary function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>n-dimensional second argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing All classes Y,X1,X2 need dim, expmap, logmap </dd></dl>

</div>
</div>
<a class="anchor" id="af6cefcc2e690755b40d84f04beb123ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix gtsam::numericalDerivative31 </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 1 of ternary function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>ternary function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing All classes Y,X1,X2,X3 need dim, expmap, logmap </dd></dl>

</div>
</div>
<a class="anchor" id="a0b4fe49c0dea74639a95bfb58e21e663"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix gtsam::numericalDerivative32 </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 2 of ternary function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>ternary function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing All classes Y,X1,X2,X3 need dim, expmap, logmap </dd></dl>

</div>
</div>
<a class="anchor" id="a5def64a08dde6bc660af18e22f69e901"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X1 , class X2 , class X3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix gtsam::numericalDerivative33 </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; Y(const X1 &amp;, const X2 &amp;, const X3 &amp;)&gt;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X3 &amp;&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute numerical derivative in argument 3 of ternary function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>ternary function yielding m-vector </td></tr>
    <tr><td class="paramname">x1</td><td>n-dimensional first argument value </td></tr>
    <tr><td class="paramname">x2</td><td>second argument value </td></tr>
    <tr><td class="paramname">x3</td><td>third argument value </td></tr>
    <tr><td class="paramname">delta</td><td>increment for numerical derivative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>m*n Jacobian computed via central differencing All classes Y,X1,X2,X3 need dim, expmap, logmap </dd></dl>

</div>
</div>
<a class="anchor" id="a11dc11c40862fe22c0ebab881edda95a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix gtsam::numericalHessian </td>
          <td>(</td>
          <td class="paramtype">boost::function&lt; double(const X &amp;)&gt;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>delta</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute numerical Hessian matrix. </p>
<p>Requires a single-argument Lie-&gt;scalar function. This is implemented simply as the derivative of the gradient. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A function taking a Lie object as input and returning a scalar </td></tr>
    <tr><td class="paramname">x</td><td>The center point for computing the Hessian </td></tr>
    <tr><td class="paramname">delta</td><td>The numerical derivative step size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n*n Hessian matrix computed via central differencing </dd></dl>

</div>
</div>
<a class="anchor" id="aa4782bb65cdbe1fdd391080d1754a20f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector gtsam::ones </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create vector initialized to ones. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade6eca65dc0168a65f641961ca97924c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a00189.html">Pose3</a> gtsam::openGL2gtsam </td>
          <td>(</td>
          <td class="paramtype">const Rot3 &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function converts an openGL camera pose to an GTSAM camera pose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">R</td><td>rotation in openGL </td></tr>
    <tr><td class="paramname">tx</td><td>x component of the translation in openGL </td></tr>
    <tr><td class="paramname">ty</td><td>y component of the translation in openGL </td></tr>
    <tr><td class="paramname">tz</td><td>z component of the translation in openGL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="a00189.html">Pose3</a> in GTSAM format </dd></dl>

</div>
</div>
<a class="anchor" id="a131393739a049cb8d3c3d0c3c6e960d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00252.html">VectorValues</a> gtsam::operator* </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorValues &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7d85957bab2d18cf56ab9aaf95a106de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::istream &amp; gtsam::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>inputStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>destinationMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a matrix from an input stream, such as a file. </p>
<p>Entries can be either tab-, space-, or comma-separated, similar to the format read by the MATLAB dlmread command. </p>

</div>
</div>
<a class="anchor" id="a4b0057879b0c5f323185452b0d1a4232"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a00187.html">Point3</a> gtsam::optimize </td>
          <td>(</td>
          <td class="paramtype">const NonlinearFactorGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Values &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>landmarkKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize for triangulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>nonlinear factors for projection </td></tr>
    <tr><td class="paramname">values</td><td>initial values </td></tr>
    <tr><td class="paramname">landmarkKey</td><td>to refer to landmark </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>refined <a class="el" href="a00187.html">Point3</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a33509e7a55b46fe677e682d01f8fbd87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CLIQUE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t gtsam::optimizeWildfire </td>
          <td>(</td>
          <td class="paramtype">const boost::shared_ptr&lt; CLIQUE &gt; &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FastSet&lt; Key &gt; &amp;&#160;</td>
          <td class="paramname"><em>replaced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorValues &amp;&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimize the <a class="el" href="a00010.html">BayesTree</a>, starting from the root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">replaced</td><td>Needs to contain all variables that are contained in the top of the Bayes tree that has been redone. </td></tr>
    <tr><td class="paramname">delta</td><td>The current solution, an offset from the linearization point. </td></tr>
    <tr><td class="paramname">threshold</td><td>The maximum change against the PREVIOUS delta for non-replaced variables that can be ignored, ie. the old delta entry is kept and recursive backsubstitution might eventually stop if none of the changed variables are contained in the subtree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of variables that were solved for </dd></dl>

</div>
</div>
<a class="anchor" id="ae67d0d86c4e55b175859967a70b36983"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class G , class V , class KEY &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::tuple&lt; G, V, std::map&lt; KEY, V &gt; &gt; gtsam::predecessorMap2Graph </td>
          <td>(</td>
          <td class="paramtype">const PredecessorMap&lt; KEY &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build takes a predecessor map, and builds a directed graph corresponding to the tree. </p>
<p>G = Graph type V = Vertex type </p>

</div>
</div>
<a class="anchor" id="ae32c295e2c40c1e85f146a8a6266eaa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::pair&lt; Matrix, Matrix &gt; gtsam::qr </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Householder QR factorization, Golub &amp; Van Loan p 224, explicit version. </p>
<p>QR factorization, inefficient, best use imperative householder below m*n matrix -&gt; m*m Q, m*n R.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>a matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&lt;Q,R&gt; rotation matrix Q, upper triangular R </dd></dl>

</div>
</div>
<a class="anchor" id="a07b97b60419b8535ccdaa385ce6d7cc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::readBAL </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SfM_data &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function parses a "Bundle Adjustment in the Large" (BAL) file and stores the data into a <a class="el" href="a00212.html" title="Define the structure for SfM data.">SfM_data</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the BAL file </td></tr>
    <tr><td class="paramname">data</td><td>SfM structure where the data is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the parsing was successful, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="aef96840653460872d4e7a74349f77c42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::readBundler </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SfM_data &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function parses a bundler output file and stores the data into a <a class="el" href="a00212.html" title="Define the structure for SfM data.">SfM_data</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the bundler file </td></tr>
    <tr><td class="paramname">data</td><td>SfM structure where the data is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the parsing was successful, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a8caf13571ec334f8d789f4acc8e2ace5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a00290.html#a62b6d8d9df4bb6e0add77af1ffd41c04">GraphAndValues</a> gtsam::readG2o </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>g2oFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KernelFunctionType&#160;</td>
          <td class="paramname"><em>kernelFunctionType</em> = <code>KernelFunctionTypeNONE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function parses a g2o file and stores the measurements into a <a class="el" href="a00173.html" title="A non-linear factor graph is a graph of non-Gaussian, i.e.">NonlinearFactorGraph</a> and the initial guess in a <a class="el" href="a00244.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the g2o file </td></tr>
    <tr><td class="paramname">kernelFunctionType</td><td>whether to wrap the noise model in a robust kernel </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>graph and initial values </dd></dl>

</div>
</div>
<a class="anchor" id="a0853fc18973e23bb407825df52c95515"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::reciprocal </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elementwise reciprocal of vector elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>[1/a(i)] </dd></dl>

</div>
</div>
<a class="anchor" id="af50343afb840c2e690b5b86b69ab691a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::repeat </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create vector initialized to a constant value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>is the size of the vector </td></tr>
    <tr><td class="paramname">value</td><td>is a constant value to insert into the vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2754f325c8600303d627d9e8cf1f9949"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MATRIX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const MATRIX::ConstRowXpr gtsam::row </td>
          <td>(</td>
          <td class="paramtype">const MATRIX &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts a row view from a matrix that avoids a copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix to extract row from </td></tr>
    <tr><td class="paramname">j</td><td>index of the row </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const view of the matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a59e7b1c395b14af00409d9ca3ee4a687"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::pair&lt; Matrix3, Vector3 &gt; gtsam::RQ </td>
          <td>(</td>
          <td class="paramtype">const Matrix3 &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>[RQ] receives a 3 by 3 matrix and returns an upper triangular matrix R and 3 rotation angles corresponding to the rotation matrix Q=Qz'*Qy'*Qx' such that A = R*Q = R*Qz'*Qy'*Qx'. </p>
<p>When A is a rotation matrix, R will be the identity and Q is a yaw-pitch-roll decomposition of A. The implementation uses Givens rotations and is based on Hartley-Zisserman. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>3 by 3 matrix A=RQ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an upper triangular matrix R </dd>
<dd>
a vector [thetax, thetay, thetaz] in radians. </dd></dl>

</div>
</div>
<a class="anchor" id="ad371582718b5e685ace31c176f2a9abc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gtsam::scal </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>BLAS Level 1 scal: x &lt;- alpha*x. </p>
<dl class="deprecated"><dt><b><a class="el" href="a00563.html#_deprecated000004">Deprecated:</a></b></dt><dd>: use operators instead </dd></dl>

</div>
</div>
<a class="anchor" id="a60bc5c23cdae085b88d12056c7411463"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Matrix3 gtsam::skewSymmetric </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>wz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>skew symmetric matrix returns this: 0 -wz wy wz 0 -wx -wy wx 0 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wx</td><td>3 dimensional vector </td></tr>
    <tr><td class="paramname">wy</td><td></td></tr>
    <tr><td class="paramname">wz</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 3*3 skew symmetric matrix </dd></dl>

</div>
</div>
<a class="anchor" id="a5c82884a356ddd09229a5283aed04df9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Matrix gtsam::stack </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrMatrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a matrix by stacking other matrices Given a set of matrices: A1, A2, A3... </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">...</td><td>pointers to matrices to be stacked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>combined matrix [A1; A2; A3] </dd></dl>

</div>
</div>
<a class="anchor" id="aed4b2ca704ddd6530ea70122f883ac88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Vector gtsam::steepestDescent </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConjugateGradientParameters &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convenience calls using matrices, will create <a class="el" href="a00230.html" title="Helper class encapsulating the combined system |Ax-b_|^2 Needed to run Conjugate Gradients on matrice...">System</a> class internally: </p>
<p>Method of steepest gradients, Matrix version </p>

</div>
</div>
<a class="anchor" id="aed6673ca73bb7ab59f46f08e3a5cc284"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MATRIX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Block&lt;const MATRIX&gt; gtsam::sub </td>
          <td>(</td>
          <td class="paramtype">const MATRIX &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extract submatrix, slice semantics, i.e. </p>
<p>range = [i1,i2[ excluding i2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix </td></tr>
    <tr><td class="paramname">i1</td><td>first row index </td></tr>
    <tr><td class="paramname">i2</td><td>last row index + 1 </td></tr>
    <tr><td class="paramname">j1</td><td>first col index </td></tr>
    <tr><td class="paramname">j2</td><td>last col index + 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>submatrix A(i1:i2-1,j1:j2-1) </dd></dl>

</div>
</div>
<a class="anchor" id="af694dd7a0838c24e3484068cc1657f4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT ConstSubVector gtsam::sub </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extract subvector, slice semantics, i.e. </p>
<p>range = [i1,i2[ excluding i2 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vector </td></tr>
    <tr><td class="paramname">i1</td><td>first row index </td></tr>
    <tr><td class="paramname">i2</td><td>last row index + 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>subvector v(i1:i2) </dd></dl>

</div>
</div>
<a class="anchor" id="abe442f79470225ffccfc8bc5ce46a87a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::subInsert </td>
          <td>(</td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>fullVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>subVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a subvector into a vector IN PLACE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fullVector</td><td>is the vector to be changed </td></tr>
    <tr><td class="paramname">subVector</td><td>is the vector to insert </td></tr>
    <tr><td class="paramname">i</td><td>is the index where the subvector should be inserted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a316a9f631367da3caae876b41b345867"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT double gtsam::sum </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sum vector elements </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum_i a(i) </dd></dl>

</div>
</div>
<a class="anchor" id="a8d7e46204d953f64a39445599dbd7eee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::svd </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SVD computes economy SVD A=U*S*V'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>an m*n matrix </td></tr>
    <tr><td class="paramname">U</td><td>output argument: rotation matrix </td></tr>
    <tr><td class="paramname">S</td><td>output argument: sorted vector of singular values </td></tr>
    <tr><td class="paramname">V</td><td>output argument: rotation matrix if m &gt; n then U*S*V' = (m*n)*(n*n)*(n*n) if m &lt; n then U*S*V' = (m*m)*(m*m)*(m*n) Careful! The dimensions above reflect V', not V, which is n*m if m&lt;n. U is a basis in R^m, V is a basis in R^n You can just pass empty matrices U,V, and vector S, they will be re-allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7cd266db68d8146af3b9b1630d4b700b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00290.html#aa365a1bd3614e767adbd35f44ba4fec3">Key</a> gtsam::symbol </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a symbol key from a character and index, i.e. </p>
<p>x5. </p>

</div>
</div>
<a class="anchor" id="a9ca9499e881d22361b4833c2854d941f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char gtsam::symbolChr </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the character portion of a symbol key. </p>

</div>
</div>
<a class="anchor" id="a901c06d89d5c4ba46d926a86b307f271"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t gtsam::symbolIndex </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the index portion of a symbol key. </p>

</div>
</div>
<a class="anchor" id="a80d640f59e5d39a1165069a3841cc5d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">P gtsam::transform_point </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>global</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; Matrix &amp; &gt;&#160;</td>
          <td class="paramname"><em>Dtrans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::optional&lt; Matrix &amp; &gt;&#160;</td>
          <td class="paramname"><em>Dglobal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform function that must be specialized specific domains. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>is a Transform type </td></tr>
    <tr><td class="paramname">P</td><td>is a point type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afac774d6d37c142606e84487c9905c02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT <a class="el" href="a00187.html">Point3</a> gtsam::triangulateDLT </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Matrix &gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Point2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rank_tol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DLT triangulation: See Hartley and Zisserman, 2nd Ed., page 312. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">projection_matrices</td><td>Projection matrices (K*P^-1) </td></tr>
    <tr><td class="paramname">measurements</td><td>2D measurements </td></tr>
    <tr><td class="paramname">rank_tol</td><td>SVD rank tolerance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Triangulated <a class="el" href="a00187.html">Point3</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a65edc51013011a97850fbe1684da14c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CALIBRATION &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00187.html">Point3</a> gtsam::triangulateNonlinear </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Pose3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>poses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; CALIBRATION &gt;&#160;</td>
          <td class="paramname"><em>sharedCal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Point2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point3 &amp;&#160;</td>
          <td class="paramname"><em>initialEstimate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an initial estimate , refine a point using measurements in several cameras. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poses</td><td>Camera poses </td></tr>
    <tr><td class="paramname">sharedCal</td><td>shared pointer to single calibration object </td></tr>
    <tr><td class="paramname">measurements</td><td>2D measurements </td></tr>
    <tr><td class="paramname">initialEstimate</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>refined <a class="el" href="a00187.html">Point3</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a50a7e844788f256cb7461d2d8a42e0ae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CALIBRATION &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00187.html">Point3</a> gtsam::triangulateNonlinear </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; PinholeCamera&lt; CALIBRATION &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cameras</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Point2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point3 &amp;&#160;</td>
          <td class="paramname"><em>initialEstimate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an initial estimate , refine a point using measurements in several cameras. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameras</td><td>pinhole cameras </td></tr>
    <tr><td class="paramname">measurements</td><td>2D measurements </td></tr>
    <tr><td class="paramname">initialEstimate</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>refined <a class="el" href="a00187.html">Point3</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a74917d865d97c3675a9358519dd28fbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CALIBRATION &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00187.html">Point3</a> gtsam::triangulatePoint3 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Pose3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>poses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; CALIBRATION &gt;&#160;</td>
          <td class="paramname"><em>sharedCal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Point2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rank_tol</em> = <code>1e-9</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to triangulate 3D landmark point from an arbitrary number of poses (at least 2) using the DLT. </p>
<p>The function checks that the resulting point lies in front of all cameras, but has no other checks to verify the quality of the triangulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poses</td><td>A vector of camera poses </td></tr>
    <tr><td class="paramname">sharedCal</td><td>shared pointer to single calibration object </td></tr>
    <tr><td class="paramname">measurements</td><td>A vector of camera measurements </td></tr>
    <tr><td class="paramname">rank</td><td>tolerance, default 1e-9 </td></tr>
    <tr><td class="paramname">optimize</td><td>Flag to turn on nonlinear refinement of triangulation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <a class="el" href="a00187.html">Point3</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0df4caa55f658b412f9c817975cb8aca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CALIBRATION &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00187.html">Point3</a> gtsam::triangulatePoint3 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; PinholeCamera&lt; CALIBRATION &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cameras</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Point2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rank_tol</em> = <code>1e-9</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimize</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to triangulate 3D landmark point from an arbitrary number of poses (at least 2) using the DLT. </p>
<p>This function is similar to the one above, except that each camera has its own calibration. The function checks that the resulting point lies in front of all cameras, but has no other checks to verify the quality of the triangulation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameras</td><td>pinhole cameras </td></tr>
    <tr><td class="paramname">measurements</td><td>A vector of camera measurements </td></tr>
    <tr><td class="paramname">rank</td><td>tolerance, default 1e-9 </td></tr>
    <tr><td class="paramname">optimize</td><td>Flag to turn on nonlinear refinement of triangulation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <a class="el" href="a00187.html">Point3</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab53edb52916aae7593c671cf5a241939"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CALIBRATION &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="a00173.html">NonlinearFactorGraph</a>, <a class="el" href="a00244.html">Values</a>&gt; gtsam::triangulationGraph </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Pose3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>poses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::shared_ptr&lt; CALIBRATION &gt;&#160;</td>
          <td class="paramname"><em>sharedCal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Point2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>landmarkKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point3 &amp;&#160;</td>
          <td class="paramname"><em>initialEstimate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a factor graph with projection factors from poses and one calibration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poses</td><td>Camera poses </td></tr>
    <tr><td class="paramname">sharedCal</td><td>shared pointer to single calibration object </td></tr>
    <tr><td class="paramname">measurements</td><td>2D measurements </td></tr>
    <tr><td class="paramname">landmarkKey</td><td>to refer to landmark </td></tr>
    <tr><td class="paramname">initialEstimate</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>graph and initial values </dd></dl>

</div>
</div>
<a class="anchor" id="a7177920d6b77c685fec4178a79eeb830"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CALIBRATION &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="a00173.html">NonlinearFactorGraph</a>, <a class="el" href="a00244.html">Values</a>&gt; gtsam::triangulationGraph </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; PinholeCamera&lt; CALIBRATION &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cameras</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Point2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>measurements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>landmarkKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point3 &amp;&#160;</td>
          <td class="paramname"><em>initialEstimate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a factor graph with projection factors from pinhole cameras (each camera has a pose and calibration) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cameras</td><td>pinhole cameras </td></tr>
    <tr><td class="paramname">measurements</td><td>2D measurements </td></tr>
    <tr><td class="paramname">landmarkKey</td><td>to refer to landmark </td></tr>
    <tr><td class="paramname">initialEstimate</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>graph and initial values </dd></dl>

</div>
</div>
<a class="anchor" id="a24d3ad0252f91f0ec301593c45cf5af7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::vector_scale_inplace </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inf_mask</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scales a matrix row or column by the values in a vector Arguments (Matrix, Vector) scales the columns, (Vector, Matrix) scales the rows </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inf_mask</td><td>when true, will not scale with a NaN or inf value. The inplace version also allows v.size()&lt;A.rows() and only scales the first v.size() rows of A. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aefb606eb24889c0f418acf1515a2c723"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix <a class="el" href="a00290.html#afe28b7f8e3592fb9f5cf9ebae09497ba">gtsam::wedge</a>&lt; <a class="el" href="a00189.html">Pose3</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>xi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wedge for <a class="el" href="a00189.html">Pose3</a>: </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xi</td><td>6-dim twist (omega,v) where omega = 3D angular velocity v = 3D velocity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>xihat, 4*4 element of Lie algebra that can be exponentiated </dd></dl>

</div>
</div>
<a class="anchor" id="a60019a03f26b92c6b2a08e43d153d4c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::list&lt; boost::tuple&lt; Vector, double, double &gt; &gt; gtsam::weighted_eliminate </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>sigmas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Imperative algorithm for in-place full elimination with weights and constraint handling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>is a matrix to eliminate </td></tr>
    <tr><td class="paramname">b</td><td>is the rhs </td></tr>
    <tr><td class="paramname">sigmas</td><td>is a vector of the measurement standard deviation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of r vectors, d and sigma </dd></dl>

</div>
</div>
<a class="anchor" id="aca1c56d11a05464a7a5458dc32ccc777"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT std::pair&lt; Vector, double &gt; gtsam::weightedPseudoinverse </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Weighted Householder solution vector, a.k.a., the pseudoinverse of the column NOTE: if any sigmas are zero (indicating a constraint) the pseudoinverse will be a selection vector, and the variance will be zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>is the first column of the matrix to solve </td></tr>
    <tr><td class="paramname">weights</td><td>is a vector of weights/precisions where w=1/(s*s) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of the pseudoinverse of v and the associated precision/weight </dd></dl>

</div>
</div>
<a class="anchor" id="acbdf1d3cfef0058a15eca02d31037e9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::writeBAL </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SfM_data &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes a "Bundle Adjustment in the Large" (BAL) file from a <a class="el" href="a00212.html" title="Define the structure for SfM data.">SfM_data</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the BAL file to write </td></tr>
    <tr><td class="paramname">data</td><td>SfM structure where the data is stored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the parsing was successful, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a28d34be139e927fde97f85d83144c02a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT bool gtsam::writeBALfromValues </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SfM_data &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Values &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes a "Bundle Adjustment in the Large" (BAL) file from a <a class="el" href="a00212.html" title="Define the structure for SfM data.">SfM_data</a> structure and a value structure (measurements are the same as the SfM input data, while camera poses and values are read from <a class="el" href="a00244.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the BAL file to write </td></tr>
    <tr><td class="paramname">data</td><td>SfM structure where the data is stored </td></tr>
    <tr><td class="paramname">values</td><td>structure where the graph values are stored (values can be either <a class="el" href="a00189.html">Pose3</a> or PinholeCamera&lt;Cal3Bundler&gt; for the cameras, and should be <a class="el" href="a00187.html">Point3</a> for the 3D points). Note that the current version assumes that the keys are "x1" for pose 1 (or "c1" for camera 1) and "l1" for landmark 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the parsing was successful, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a68bc584d72da3747666ac134a9490f92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT void gtsam::writeG2o </td>
          <td>(</td>
          <td class="paramtype">const NonlinearFactorGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Values &amp;&#160;</td>
          <td class="paramname"><em>estimate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function writes a g2o file from <a class="el" href="a00173.html" title="A non-linear factor graph is a graph of non-Gaussian, i.e.">NonlinearFactorGraph</a> and a <a class="el" href="a00244.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the g2o file to write </td></tr>
    <tr><td class="paramname">graph</td><td><a class="el" href="a00172.html" title="Nonlinear factor base class.">NonlinearFactor</a> graph storing the measurements </td></tr>
    <tr><td class="paramname">estimate</td><td><a class="el" href="a00244.html" title="A non-templated config holding any types of Manifold-group elements.">Values</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a067f9515f6cd64987f4604127398fb9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector gtsam::zero </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create zero vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57edf6ed7312f63d35f73233665c334d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MATRIX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gtsam::zeroBelowDiagonal </td>
          <td>(</td>
          <td class="paramtype">MATRIX &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cols</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zeros all of the elements below the diagonal of a matrix, in place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>is a matrix, to be modified in place </td></tr>
    <tr><td class="paramname">cols</td><td>is the number of columns to zero, use zero for all columns </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33240affd7dc54b7a85c6f3136853f7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GTSAM_EXPORT Matrix gtsam::zeros </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an zeros matrix, with matlab-like syntax. </p>
<p>Note: if assigning a block (created from an Eigen block() function) of a matrix to zeros, don't use this function, instead use ".setZero(m,n)" to avoid an Eigen error. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00290.html">gtsam</a></li>
    <li class="footer">Generated on Sun Jun 1 2014 16:44:45 for gtsam by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
